{
  "version": 3,
  "sources": ["../../../../../node_modules/buffer/index.js", "../../@dfinity/agent/src/actor.ts", "../../@dfinity/agent/src/agent/api.ts", "../../@dfinity/agent/src/auth.ts", "../../@dfinity/agent/src/agent/http/transforms.ts", "../../@dfinity/agent/src/agent/http/types.ts", "../../@dfinity/agent/src/agent/http/errors.ts", "../../../../../node_modules/@noble/curves/src/abstract/edwards.ts", "../../../../../node_modules/@noble/curves/src/abstract/montgomery.ts", "../../../../../node_modules/@noble/curves/src/ed25519.ts", "../../@dfinity/agent/src/utils/expirableMap.ts", "../../@dfinity/agent/src/der.ts", "../../@dfinity/agent/src/public_key.ts", "../../@dfinity/agent/src/polling/backoff.ts", "../../@dfinity/agent/src/agent/http/index.ts", "../../@dfinity/agent/src/agent/proxy.ts", "../../@dfinity/agent/src/polling/index.ts", "../../@dfinity/agent/src/polling/strategy.ts", "../../@dfinity/identity/src/identity/ed25519.ts", "../../@dfinity/identity/src/identity/ecdsa.ts", "../../@dfinity/identity/src/identity/delegation.ts", "../../@dfinity/identity/src/identity/partial.ts", "../../@dfinity/identity/src/identity/webauthn.ts", "../../@dfinity/auth-client/src/idleManager.ts", "../../../../../node_modules/idb/build/wrap-idb-value.js", "../../../../../node_modules/idb/build/index.js", "../../@dfinity/auth-client/src/db.ts", "../../@dfinity/auth-client/src/storage.ts", "../../@dfinity/auth-client/src/index.ts"],
  "sourcesContent": ["/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "import { Buffer } from 'buffer/';\nimport {\n  Agent,\n  getDefaultAgent,\n  HttpDetailsResponse,\n  QueryResponseRejected,\n  QueryResponseStatus,\n  ReplicaRejectCode,\n  SubmitResponse,\n} from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, PollStrategyFactory, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { RequestId } from './request_id';\nimport { toHex } from './utils/buffer';\nimport { CreateCertificateOptions } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nimport _SERVICE, { canister_install_mode, canister_settings } from './canisters/management_service';\n\nexport class ActorCallError extends AgentError {\n  constructor(\n    public readonly canisterId: Principal,\n    public readonly methodName: string,\n    public readonly type: 'query' | 'update',\n    public readonly props: Record<string, string>,\n  ) {\n    super(\n      [\n        `Call failed:`,\n        `  Canister: ${canisterId.toText()}`,\n        `  Method: ${methodName} (${type})`,\n        ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n      ].join('\\n'),\n    );\n  }\n}\n\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly result: QueryResponseRejected,\n  ) {\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: ReplicaRejectCode[result.reject_code] ?? `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message,\n    });\n  }\n}\n\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly requestId: RequestId,\n    public readonly response: SubmitResponse['response'],\n  ) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      ...(response.body\n        ? {\n            ...(response.body.error_code\n              ? {\n                  'Error code': response.body.error_code,\n                }\n              : {}),\n            'Reject code': String(response.body.reject_code),\n            'Reject message': response.body.reject_message,\n          }\n        : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n          }),\n    });\n  }\n}\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * A polling strategy factory that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   */\n  pollingStrategyFactory?: PollStrategyFactory;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n}\n\ninterface CreateCanisterSettings {\n  freezing_threshold?: bigint;\n  controllers?: Array<Principal>;\n  memory_allocation?: bigint;\n  compute_allocation?: bigint;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static async install(\n    fields: {\n      module: ArrayBuffer;\n      mode?: canister_install_mode;\n      arg?: ArrayBuffer;\n    },\n    config: ActorConfig,\n  ): Promise<void> {\n    const mode = fields.mode === undefined ? { install: null } : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId =\n      typeof config.canisterId === 'string'\n        ? Principal.fromText(config.canisterId)\n        : config.canisterId;\n\n    await getManagementCanister(config).install_code({\n      mode,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n      sender_canister_version: [],\n    });\n  }\n\n  public static async createCanister(\n    config?: CallConfig,\n    settings?: CreateCanisterSettings,\n  ): Promise<Principal> {\n    function settingsToCanisterSettings(settings: CreateCanisterSettings): [canister_settings] {\n      return [\n        {\n          controllers: settings.controllers ? [settings.controllers] : [],\n          compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n          freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n          memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n          reserved_cycles_limit: [],\n          log_visibility: [],\n          wasm_memory_limit: [],\n        },\n      ];\n    }\n\n    const { canister_id: canisterId } = await getManagementCanister(\n      config || {},\n    ).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: settingsToCanisterSettings(settings || {}),\n      specified_id: [],\n      sender_canister_version: [],\n    });\n\n    return canisterId;\n  }\n\n  public static async createAndInstallCanister(\n    interfaceFactory: IDL.InterfaceFactory,\n    fields: {\n      module: ArrayBuffer;\n      arg?: ArrayBuffer;\n    },\n    config?: CallConfig,\n  ): Promise<ActorSubclass> {\n    const canisterId = await this.createCanister(config);\n    await this.install(\n      {\n        ...fields,\n      },\n      { ...config, canisterId },\n    );\n\n    return this.createActor(interfaceFactory, { ...config, canisterId });\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId)\n          throw new AgentError(\n            `Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n          );\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw new AgentError(\n        `Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n      );\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: ArrayBuffer) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails: result.httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const { requestId, response } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n      });\n\n      if (!response.ok || response.body /* IC-1462 */) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n\n      const pollStrategy = pollingStrategyFactory();\n      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n\n      if (responseBytes !== undefined) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: decodeReturnValue(func.retTypes, responseBytes),\n            }\n          : decodeReturnValue(func.retTypes, responseBytes);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n\nexport type ManagementCanisterRecord = _SERVICE;\n\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nexport function getManagementCanister(config: CallConfig): ActorSubclass<ManagementCanisterRecord> {\n  function transform(\n    _methodName: string,\n    args: Record<string, unknown> & { canister_id: string }[],\n  ) {\n    if (config.effectiveCanisterId) {\n      return { effectiveCanisterId: Principal.from(config.effectiveCanisterId) };\n    }\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id as unknown);\n    }\n    return { effectiveCanisterId };\n  }\n\n  return Actor.createActor<ManagementCanisterRecord>(managementCanisterIdl, {\n    ...config,\n    canisterId: Principal.fromHex(''),\n    ...{\n      callTransform: transform,\n      queryTransform: transform,\n    },\n  });\n}\n", "import { Principal } from '@dfinity/principal';\nimport { RequestId } from '../request_id';\nimport { JsonObject } from '@dfinity/candid';\nimport { Identity } from '../auth';\nimport { HttpHeaderField } from './http/types';\n\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nexport enum ReplicaRejectCode {\n  SysFatal = 1,\n  SysTransient = 2,\n  DestinationInvalid = 3,\n  CanisterReject = 4,\n  CanisterError = 5,\n}\n\n/**\n * Options when doing a {@link Agent.readState} call.\n */\nexport interface ReadStateOptions {\n  /**\n   * A list of paths to read the state of.\n   */\n  paths: ArrayBuffer[][];\n}\n\n/**\n *\n */\nexport type QueryResponse = QueryResponseReplied | QueryResponseRejected;\n\nexport const enum QueryResponseStatus {\n  Replied = 'replied',\n  Rejected = 'rejected',\n}\n\nexport interface HttpDetailsResponse {\n  ok: boolean;\n  status: number;\n  statusText: string;\n  headers: HttpHeaderField[];\n}\n\nexport type ApiQueryResponse = QueryResponse & {\n  httpDetails: HttpDetailsResponse;\n  requestId: RequestId;\n};\n\nexport interface QueryResponseBase {\n  status: QueryResponseStatus;\n}\n\nexport type NodeSignature = {\n  // the batch time\n  timestamp: bigint;\n  // the signature\n  signature: Uint8Array;\n  // the ID of the node that created the signature\n  identity: Uint8Array;\n};\n\nexport interface QueryResponseReplied extends QueryResponseBase {\n  status: QueryResponseStatus.Replied;\n  reply: { arg: ArrayBuffer };\n  signatures?: NodeSignature[];\n}\n\nexport interface QueryResponseRejected extends QueryResponseBase {\n  status: QueryResponseStatus.Rejected;\n  reject_code: ReplicaRejectCode;\n  reject_message: string;\n  error_code: string;\n  signatures?: NodeSignature[];\n}\n\n/**\n * Options when doing a {@link Agent.query} call.\n */\nexport interface QueryFields {\n  /**\n   * The method name to call.\n   */\n  methodName: string;\n\n  /**\n   * A binary encoded argument. This is already encoded and will be sent as is.\n   */\n  arg: ArrayBuffer;\n\n  /**\n   * Overrides canister id for path to fetch. This is used for management canister calls.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Options when doing a {@link Agent.call} call.\n */\nexport interface CallOptions {\n  /**\n   * The method name to call.\n   */\n  methodName: string;\n\n  /**\n   * A binary encoded argument. This is already encoded and will be sent as is.\n   */\n  arg: ArrayBuffer;\n\n  /**\n   * An effective canister ID, used for routing. This should only be mentioned if\n   * it's different from the canister ID.\n   */\n  effectiveCanisterId: Principal | string;\n}\n\nexport interface ReadStateResponse {\n  certificate: ArrayBuffer;\n}\n\nexport interface SubmitResponse {\n  requestId: RequestId;\n  response: {\n    ok: boolean;\n    status: number;\n    statusText: string;\n    body: {\n      error_code?: string;\n      reject_code: number;\n      reject_message: string;\n    } | null;\n    headers: HttpHeaderField[];\n  };\n}\n\n/**\n * An Agent able to make calls and queries to a Replica.\n */\nexport interface Agent {\n  readonly rootKey: ArrayBuffer | null;\n  /**\n   * Returns the principal ID associated with this agent (by default). It only shows\n   * the principal of the default identity in the agent, which is the principal used\n   * when calls don't specify it.\n   */\n  getPrincipal(): Promise<Principal>;\n\n  /**\n   * Create the request for the read state call.\n   * `readState` uses this internally.\n   * Useful to avoid signing the same request multiple times.\n   */\n  createReadStateRequest?(\n    options: ReadStateOptions,\n    identity?: Identity,\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  ): Promise<any>;\n\n  /**\n   * Send a read state query to the replica. This includes a list of paths to return,\n   * and will return a Certificate. This will only reject on communication errors,\n   * but the certificate might contain less information than requested.\n   * @param effectiveCanisterId A Canister ID related to this call.\n   * @param options The options for this call.\n   * @param identity Identity for the call. If not specified, uses the instance identity.\n   * @param request The request to send in case it has already been created.\n   */\n  readState(\n    effectiveCanisterId: Principal | string,\n    options: ReadStateOptions,\n    identity?: Identity,\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    request?: any,\n  ): Promise<ReadStateResponse>;\n\n  call(canisterId: Principal | string, fields: CallOptions): Promise<SubmitResponse>;\n\n  /**\n   * Query the status endpoint of the replica. This normally has a few fields that\n   * corresponds to the version of the replica, its root public key, and any other\n   * information made public.\n   * @returns A JsonObject that is essentially a record of fields from the status\n   *     endpoint.\n   */\n  status(): Promise<JsonObject>;\n\n  /**\n   * Send a query call to a canister. See\n   * {@link https://sdk.dfinity.org/docs/interface-spec/#http-query | the interface spec}.\n   * @param canisterId The Principal of the Canister to send the query to. Sending a query to\n   *     the management canister is not supported (as it has no meaning from an agent).\n   * @param options Options to use to create and send the query.\n   * @param identity Sender principal to use when sending the query.\n   * @returns The response from the replica. The Promise will only reject when the communication\n   *     failed. If the query itself failed but no protocol errors happened, the response will\n   *     be of type QueryResponseRejected.\n   */\n  query(\n    canisterId: Principal | string,\n    options: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse>;\n\n  /**\n   * By default, the agent is configured to talk to the main Internet Computer,\n   * and verifies responses using a hard-coded public key.\n   *\n   * This function will instruct the agent to ask the endpoint for its public\n   * key, and use that instead. This is required when talking to a local test\n   * instance, for example.\n   *\n   * Only use this when you are  _not_ talking to the main Internet Computer,\n   * otherwise you are prone to man-in-the-middle attacks! Do not call this\n   * function by default.\n   */\n  fetchRootKey(): Promise<ArrayBuffer>;\n  /**\n   * If an application needs to invalidate an identity under certain conditions, an `Agent` may expose an `invalidateIdentity` method.\n   * Invoking this method will set the inner identity used by the `Agent` to `null`.\n   *\n   * A use case for this would be - after a certain period of inactivity, a secure application chooses to invalidate the identity of any `HttpAgent` instances. An invalid identity can be replaced by `Agent.replaceIdentity`\n   */\n  invalidateIdentity?(): void;\n  /**\n   * If an application needs to replace an identity under certain conditions, an `Agent` may expose a `replaceIdentity` method.\n   * Invoking this method will set the inner identity used by the `Agent` to a newly provided identity.\n   *\n   * A use case for this would be - after authenticating using `@dfinity/auth-client`, you can replace the `AnonymousIdentity` of your `Actor` with a `DelegationIdentity`.\n   *\n   * ```Actor.agentOf(defaultActor).replaceIdentity(await authClient.getIdentity());```\n   */\n  replaceIdentity?(identity: Identity): void;\n}\n", "import { Principal } from '@dfinity/principal';\nimport { HttpAgentRequest } from './agent/http/types';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n\n/**\n * A Key Pair, containing a secret and public key.\n */\nexport interface KeyPair {\n  secretKey: ArrayBuffer;\n  publicKey: PublicKey;\n}\n\n/**\n * A public key that is DER encoded. This is a branded ArrayBuffer.\n */\nexport type DerEncodedPublicKey = ArrayBuffer & { __derEncodedPublicKey__?: void };\n\n/**\n * A signature array buffer.\n */\nexport type Signature = ArrayBuffer & { __signature__: void };\n\n/**\n * A Public Key implementation.\n */\nexport interface PublicKey {\n  toDer(): DerEncodedPublicKey;\n  // rawKey, toRaw, and derKey are optional for backwards compatibility.\n  toRaw?(): ArrayBuffer;\n  rawKey?: ArrayBuffer;\n  derKey?: DerEncodedPublicKey;\n}\n\n/**\n * A General Identity object. This does not have to be a private key (for example,\n * the Anonymous identity), but it must be able to transform request.\n */\nexport interface Identity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal(): Principal;\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   */\n  transformRequest(request: HttpAgentRequest): Promise<unknown>;\n}\n\n/**\n * An Identity that can sign blobs.\n */\nexport abstract class SignIdentity implements Identity {\n  protected _principal: Principal | undefined;\n\n  /**\n   * Returns the public key that would match this identity's signature.\n   */\n  public abstract getPublicKey(): PublicKey;\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   */\n  public abstract sign(blob: ArrayBuffer): Promise<Signature>;\n\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  public getPrincipal(): Principal {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concat(domainSeparator, requestId)),\n      },\n    };\n  }\n}\n\nexport class AnonymousIdentity implements Identity {\n  public getPrincipal(): Principal {\n    return Principal.anonymous();\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    return {\n      ...request,\n      body: { content: request.body },\n    };\n  }\n}\n\n/*\n * We need to communicate with other agents on the page about identities,\n * but those messages may need to go across boundaries where it's not possible to\n * serialize/deserialize object prototypes easily.\n * So these are lightweight, serializable objects that contain enough information to recreate\n * SignIdentities, but don't commit to having all methods of SignIdentity.\n *\n * Use Case:\n * * DOM Events that let differently-versioned components communicate to one another about\n *   Identities, even if they're using slightly different versions of agent packages to\n *   create/interpret them.\n */\nexport interface AnonymousIdentityDescriptor {\n  type: 'AnonymousIdentity';\n}\nexport interface PublicKeyIdentityDescriptor {\n  type: 'PublicKeyIdentity';\n  publicKey: string;\n}\nexport type IdentityDescriptor = AnonymousIdentityDescriptor | PublicKeyIdentityDescriptor;\n\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(\n  identity: SignIdentity | AnonymousIdentity,\n): IdentityDescriptor {\n  const identityIndicator: IdentityDescriptor =\n    'getPublicKey' in identity\n      ? { type: 'PublicKeyIdentity', publicKey: toHex(identity.getPublicKey().toDer()) }\n      : { type: 'AnonymousIdentity' };\n  return identityIndicator;\n}\n", "import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport {\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpHeaderField,\n  makeNonce,\n  Nonce,\n} from './types';\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1_000_000);\n\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\n\nexport class Expiry {\n  private readonly _value: bigint;\n\n  constructor(deltaInMSec: number) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    const raw_value =\n      BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n      NANOSECONDS_PER_MILLISECONDS;\n\n    // round down to the nearest second\n    const ingress_as_seconds = raw_value / BigInt(1_000_000_000);\n\n    // round down to nearest minute\n    const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n\n    const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1_000_000_000);\n\n    this._value = rounded_down_nanos;\n  }\n\n  public toCBOR(): cbor.CborValue {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n\n  public toHash(): ArrayBuffer {\n    return lebEncode(this._value);\n  }\n}\n\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn: () => Nonce = makeNonce): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds: number): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers: Headers): HttpHeaderField[] {\n  const headerFields: HttpHeaderField[] = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}\n", "import type { Principal } from '@dfinity/principal';\nimport { Expiry } from './transforms';\nimport { randomNumber } from '../../utils/random';\n\n/**\n * @internal\n */\nexport const enum Endpoint {\n  Query = 'read',\n  ReadState = 'read_state',\n  Call = 'call',\n}\n\n// An HttpAgent request, before it gets encoded and sent to the server.\n// We create an empty request that we will fill later.\nexport type HttpAgentRequest =\n  | HttpAgentQueryRequest\n  | HttpAgentSubmitRequest\n  | HttpAgentReadStateRequest;\n\nexport interface HttpAgentBaseRequest {\n  readonly endpoint: Endpoint;\n  request: RequestInit;\n}\n\nexport type HttpHeaderField = [string, string];\n\nexport interface HttpAgentSubmitRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.Call;\n  body: CallRequest;\n}\n\nexport interface HttpAgentQueryRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.Query;\n  body: ReadRequest;\n}\n\nexport interface HttpAgentReadStateRequest extends HttpAgentBaseRequest {\n  readonly endpoint: Endpoint.ReadState;\n  body: ReadRequest;\n}\n\nexport interface Signed<T> {\n  content: T;\n  sender_pubkey: ArrayBuffer;\n  sender_sig: ArrayBuffer;\n}\n\nexport interface UnSigned<T> {\n  content: T;\n}\n\nexport type Envelope<T> = Signed<T> | UnSigned<T>;\n\nexport interface HttpAgentRequestTransformFn {\n  (args: HttpAgentRequest): Promise<HttpAgentRequest | undefined | void>;\n  priority?: number;\n}\n\n// The fields in a \"call\" submit request.\nexport interface CallRequest extends Record<string, any> {\n  request_type: SubmitRequestType.Call;\n  canister_id: Principal;\n  method_name: string;\n  arg: ArrayBuffer;\n  sender: Uint8Array | Principal;\n  ingress_expiry: Expiry;\n}\n\n// The types of values allowed in the `request_type` field for submit requests.\nexport enum SubmitRequestType {\n  Call = 'call',\n}\n\n// The types of values allowed in the `request_type` field for read requests.\nexport const enum ReadRequestType {\n  Query = 'query',\n  ReadState = 'read_state',\n}\n\n// The fields in a \"query\" read request.\nexport interface QueryRequest extends Record<string, any> {\n  request_type: ReadRequestType.Query;\n  canister_id: Principal;\n  method_name: string;\n  arg: ArrayBuffer;\n  sender: Uint8Array | Principal;\n  ingress_expiry: Expiry;\n}\n\nexport interface ReadStateRequest extends Record<string, any> {\n  request_type: ReadRequestType.ReadState;\n  paths: ArrayBuffer[][];\n  ingress_expiry: Expiry;\n  sender: Uint8Array | Principal;\n}\n\nexport type ReadRequest = QueryRequest | ReadStateRequest;\n\n// A Nonce that can be used for calls.\nexport type Nonce = Uint8Array & { __nonce__: void };\n\n/**\n * Create a random Nonce, based on random values\n */\nexport function makeNonce(): Nonce {\n  // Encode 128 bits.\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n  const rand1 = randomNumber();\n  const rand2 = randomNumber();\n  const rand3 = randomNumber();\n  const rand4 = randomNumber();\n\n  view.setUint32(0, rand1);\n  view.setUint32(4, rand2);\n  view.setUint32(8, rand3);\n  view.setUint32(12, rand4);\n\n  return buffer as Nonce;\n}\n", "import { AgentError } from '../../errors';\nimport { HttpDetailsResponse } from '../api';\n\nexport class AgentHTTPResponseError extends AgentError {\n  constructor(message: string, public readonly response: HttpDetailsResponse) {\n    super(message);\n    this.name = this.constructor.name;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  ensureBytes,\n  memoized,\n  numberToBytesLE,\n  randomBytes,\n  type FHash,\n  type Hex,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveInfo,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { Field, type IField, type NLength } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\nexport type UVRatio = (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n\n// TODO: remove\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  /** @deprecated the property will be removed in next release */\n  hash: FHash; // Hashing\n  randomBytes?: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: UVRatio; // Ratio (u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// TODO: remove\nexport type CurveTypeWithLength = Readonly<CurveType & Partial<NLength>>;\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n  /** @deprecated use .X */\n  readonly ex: bigint;\n  /** @deprecated use .Y */\n  readonly ey: bigint;\n  /** @deprecated use .Z */\n  readonly ez: bigint;\n  /** @deprecated use .T */\n  readonly et: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<bigint, EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: Hex, zip215?: boolean): EdwardsPoint;\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: EdwardsPoint[], scalars: bigint[]): EdwardsPoint;\n}\n/** @deprecated use EdwardsPoint */\nexport type ExtPointType = EdwardsPoint;\n/** @deprecated use EdwardsPointCons */\nexport type ExtPointConstructor = EdwardsPointCons;\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating (u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Hex) => Uint8Array;\n  sign: (message: Hex, secretKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     * @example\n     * ```js\n     * const someonesPub = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const aPriv = x25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(aPriv, ed25519.utils.toMontgomery(someonesPub))\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv = ed25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(ed25519.utils.toMontgomeryPriv(aPriv), someonesPub)\n     * ```\n     */\n    toMontgomeryPriv: (privateKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: EdwardsPoint) => EdwardsPoint;\n  };\n  info: CurveInfo;\n}\n\n// Legacy params. TODO: remove\nexport type CurveFn = {\n  /** @deprecated the property will be removed in next release */\n  CURVE: CurveType;\n  keygen: EdDSA['keygen'];\n  getPublicKey: EdDSA['getPublicKey'];\n  sign: EdDSA['sign'];\n  verify: EdDSA['verify'];\n  Point: EdwardsPointCons;\n  /** @deprecated use `Point` */\n  ExtendedPoint: EdwardsPointCons;\n  utils: EdDSA['utils'];\n  info: CurveInfo;\n};\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(CURVE: EdwardsOpts, curveOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const { Fp, Fn } = _createCurveFields('edwards', CURVE, curveOpts);\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(curveOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    curveOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax + y = 1 + dxy should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax + y = 1 + dxy\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X\n    const Y2 = modP(Y * Y); // Y\n    const Z2 = modP(Z * Z); // Z\n    const Z4 = modP(Z2 * Z2); // Z\n    const aX2 = modP(X2 * a); // aX\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // fields\n    static readonly Fp = Fp;\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    // TODO: remove\n    get ex(): bigint {\n      return this.X;\n    }\n    get ey(): bigint {\n      return this.Y;\n    }\n    get ez(): bigint {\n      return this.Z;\n    }\n    get et(): bigint {\n      return this.T;\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return Point.ZERO;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.unsafe(this, n, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      abytes(bytes);\n      return Point.fromHex(bytes, zip215);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n      // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y - 1\n      const v = modP(d * y2 - a); // v = d y + 1.\n      let { isValid, value: x } = uvRatio(u, v); // (u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes(): Uint8Array {\n      return this.toBytes();\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BYTES * 8); // Fn.BITS?\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    throw new Error('fromBytes must be implemented by subclass');\n  }\n\n  static fromHex(_hex: Hex): any {\n    throw new Error('fromHex must be implemented by subclass');\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array {\n    return this.toBytes();\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  _validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE: G, Fp, Fn } = Point;\n  const CURVE_ORDER = Fn.ORDER;\n\n  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  function modN(a: bigint) {\n    return Fn.create(a);\n  }\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Hex): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, secretKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const L = Fp.BYTES;\n    const res = concatBytes(R, numberToBytesLE(s, L));\n    return ensureBytes('result', res, L * 2); // 64-byte signature\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Hex; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const size = Fp.BYTES;\n  const lengths = {\n    secret: size,\n    public: size,\n    signature: 2 * size,\n    seed: size,\n  };\n  function randomSecretKey(seed = randomBytes_!(lengths.seed)): Uint8Array {\n    return seed;\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomSecretKey,\n\n    isValidSecretKey,\n    isValidPublicKey,\n\n    randomPrivateKey: randomSecretKey,\n\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n\n    toMontgomeryPriv(privateKey: Uint8Array): Uint8Array {\n      abytes(privateKey, size);\n      const hashed = cHash(privateKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: EdwardsPoint = Point.BASE): EdwardsPoint {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  function keygen(seed?: Uint8Array) {\n    const secretKey = utils.randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n\n  function isValidSecretKey(key: Uint8Array): boolean {\n    try {\n      return !!Fn.fromBytes(key, false);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    info: { type: 'edwards' as const, lengths },\n  });\n}\n\n// TODO: remove\nexport type EdComposed = {\n  CURVE: EdwardsOpts;\n  curveOpts: EdwardsExtraOpts;\n  hash: FHash;\n  eddsaOpts: EdDSAOpts;\n};\n// TODO: remove\nfunction _eddsa_legacy_opts_to_new(c: CurveTypeWithLength): EdComposed {\n  const CURVE: EdwardsOpts = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts: EdwardsExtraOpts = { Fp, Fn, uvRatio: c.uvRatio };\n  const eddsaOpts: EdDSAOpts = {\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve,\n  };\n  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };\n}\n// TODO: remove\nfunction _eddsa_new_output_to_legacy(c: CurveTypeWithLength, eddsa: EdDSA): CurveFn {\n  const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c: CurveTypeWithLength): CurveFn {\n  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, hash, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  randomBytes,\n} from '../utils.ts';\nimport type { CurveInfo } from './curve.ts';\nimport { mod } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type MontgomeryECDH = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (secretKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (secretKey: Hex) => Uint8Array;\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: () => Uint8Array;\n  };\n  GuBytes: Uint8Array;\n  info: {\n    type: 'montgomery';\n    lengths: Omit<CurveInfo['lengths'], 'signature'>;\n    publicKeyHasPrefix?: boolean;\n  };\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n};\nexport type CurveFn = MontgomeryECDH;\n\nfunction validateOpts(curve: CurveType) {\n  _validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): MontgomeryECDH {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || randomBytes;\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n  const randomSecretKey = (seed = randomBytes_(fieldLen)) => seed;\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n  };\n  function keygen(seed?: Uint8Array) {\n    const secretKey = utils.randomSecretKey(seed);\n    return { secretKey, publicKey: scalarMultBase(secretKey) };\n  }\n  const lengths = {\n    secret: fieldLen,\n    public: fieldLen,\n    seed: fieldLen,\n  };\n  return {\n    keygen,\n    getSharedSecret: (secretKey: Hex, publicKey: Hex) => scalarMult(secretKey, publicKey),\n    getPublicKey: (secretKey: Hex): Uint8Array => scalarMultBase(secretKey),\n    scalarMult,\n    scalarMultBase,\n    utils,\n    GuBytes: GuBytes.slice(),\n    info: { type: 'montgomery' as const, lengths },\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { pippenger, type AffinePoint } from './abstract/curve.ts';\nimport {\n  PrimeEdwardsPoint,\n  twistedEdwards,\n  type CurveFn,\n  type EdwardsOpts,\n  type EdwardsPoint,\n} from './abstract/edwards.ts';\nimport {\n  _DST_scalar,\n  createHasher,\n  expand_message_xmd,\n  type H2CHasher,\n  type H2CHasherBase,\n  type H2CMethod,\n  type htfBasicOpts,\n} from './abstract/hash-to-curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  FpSqrtEven,\n  isNegativeLE,\n  mod,\n  pow2,\n  type IField,\n} from './abstract/modular.ts';\nimport { montgomery, type MontgomeryECDH as XCurveFn } from './abstract/montgomery.ts';\nimport { bytesToNumberLE, ensureBytes, equalBytes, numberToBytesLE, type Hex } from './utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// P = 2n**255n - 19n\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE: EdwardsOpts = {\n  p: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'),\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n};\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE.p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE.p;\n  const v3 = mod(v * v * v, P); // v\n  const v7 = mod(v3 * v3 * v, P); // v\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\nconst Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();\nconst Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n  ...ed25519_CURVE,\n  Fp,\n  hash: sha512,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/v\n  uvRatio,\n}))();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\n/** Context of ed25519. Uses context for domain separation. */\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\n\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE.p;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  return ed25519.utils.toMontgomery(ensureBytes('pub', edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub;\n\n/** @deprecated use `ed25519.utils.toMontgomeryPriv` */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  return ed25519.utils.toMontgomeryPriv(ensureBytes('pub', edwardsPriv));\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\n\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = EdwardsPoint;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\nfunction ristretto255_map(bytes: Uint8Array): _RistrettoPoint {\n  abytes(bytes, 64);\n  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n  const R1 = calcElligatorRistrettoMap(r1);\n  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n  const R2 = calcElligatorRistrettoMap(r2);\n  return new _RistrettoPoint(R1.add(R2));\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint<_RistrettoPoint> {\n  // Do NOT change syntax: the following gymnastics is done,\n  // because typescript strips comments, which makes bundlers disable tree-shaking.\n  // prettier-ignore\n  static BASE: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();\n  // prettier-ignore\n  static ZERO: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();\n  // prettier-ignore\n  static Fp: IField<bigint> =\n    /* @__PURE__ */ Fp;\n  // prettier-ignore\n  static Fn: IField<bigint> =\n    /* @__PURE__ */ Fn;\n\n  constructor(ep: ExtendedPoint) {\n    super(ep);\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): _RistrettoPoint {\n    return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n  }\n\n  protected assertSame(other: _RistrettoPoint): void {\n    if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');\n  }\n\n  protected init(ep: EdwardsPoint): _RistrettoPoint {\n    return new _RistrettoPoint(ep);\n  }\n\n  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\n  static hashToCurve(hex: Hex): _RistrettoPoint {\n    return ristretto255_map(ensureBytes('ristrettoHash', hex, 64));\n  }\n\n  static fromBytes(bytes: Uint8Array): _RistrettoPoint {\n    abytes(bytes, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = Fp.ORDER;\n    const mod = Fp.create;\n    const s = bytes255ToNumberLE(bytes);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), bytes) || isNegativeLE(s, P))\n      throw new Error('invalid ristretto255 encoding 1');\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n)\n      throw new Error('invalid ristretto255 encoding 2');\n    return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): _RistrettoPoint {\n    return _RistrettoPoint.fromBytes(ensureBytes('ristrettoHex', hex, 32));\n  }\n\n  static msm(points: _RistrettoPoint[], scalars: bigint[]): _RistrettoPoint {\n    return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { X, Y, Z, T } = this.ep;\n    const P = Fp.ORDER;\n    const mod = Fp.create;\n    const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n    const u2 = mod(X * Y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * T); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(T * zInv, P)) {\n      let _x = mod(Y * SQRT_M1);\n      let _y = mod(X * SQRT_M1);\n      X = _x;\n      Y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(X * zInv, P)) Y = mod(-Y); // 9\n    let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: _RistrettoPoint): boolean {\n    this.assertSame(other);\n    const { X: X1, Y: Y1 } = this.ep;\n    const { X: X2, Y: Y2 } = other.ep;\n    const mod = Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  is0(): boolean {\n    return this.equals(_RistrettoPoint.ZERO);\n  }\n}\n\n/** @deprecated use `ristretto255.Point` */\nexport const RistrettoPoint: typeof _RistrettoPoint = _RistrettoPoint;\n\nexport const ristretto255: {\n  Point: typeof _RistrettoPoint;\n} = { Point: _RistrettoPoint };\n\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher: H2CHasherBase<bigint> = {\n  hashToCurve(msg: Uint8Array, options?: htfBasicOpts): _RistrettoPoint {\n    const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n    return ristretto255_map(expand_message_xmd(msg, DST, 64, sha512));\n  },\n  hashToScalar(msg: Uint8Array, options: htfBasicOpts = { DST: _DST_scalar }) {\n    return Fn.create(bytesToNumberLE(expand_message_xmd(msg, options.DST, 64, sha512)));\n  },\n};\n\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\ntype RistHasher = (msg: Uint8Array, options: htfBasicOpts) => _RistrettoPoint;\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToRistretto255: RistHasher = /* @__PURE__ */ (() =>\n  ristretto255_hasher.hashToCurve as RistHasher)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hash_to_ristretto255: RistHasher = /* @__PURE__ */ (() =>\n  ristretto255_hasher.hashToCurve as RistHasher)();\n\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n", "export type ExpirableMapOptions<K, V> = {\n  source?: Iterable<[K, V]>;\n  expirationTime?: number;\n};\n\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap<K, V> implements Map<K, V> {\n  // Internals\n  #inner: Map<K, { value: V; timestamp: number }>;\n  #expirationTime: number;\n\n  [Symbol.iterator]: () => IterableIterator<[K, V]> = this.entries.bind(this);\n  [Symbol.toStringTag] = 'ExpirableMap';\n\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor(options: ExpirableMapOptions<K, V> = {}) {\n    const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map(\n      [...source].map(([key, value]) => [key, { value, timestamp: currentTime }]),\n    );\n    this.#expirationTime = expirationTime;\n  }\n\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n\n  // Implementing the Map interface\n\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key: K, value: V) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now(),\n    };\n    this.#inner.set(key, entry);\n\n    return this;\n  }\n\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key: K) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries(): IterableIterator<[K, V]> {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value] as [K, V];\n      }\n    };\n    return generator();\n  }\n\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values(): IterableIterator<V> {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n    };\n    return generator();\n  }\n\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys(): IterableIterator<K> {\n    return this.#inner.keys();\n  }\n\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: ExpirableMap<K, V>) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key: K): boolean {\n    return this.#inner.has(key);\n  }\n\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key: K) {\n    return this.#inner.delete(key);\n  }\n\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}\n", "import { bufEquals } from './utils/buffer';\n\nexport const encodeLenBytes = (len: number): number => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const encodeLen = (buf: Uint8Array, offset: number, len: number): number => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const decodeLenBytes = (buf: Uint8Array, offset: number): number => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw new Error('Invalid length 0');\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw new Error('Length too long (> 4 bytes)');\n};\n\nexport const decodeLen = (buf: Uint8Array, offset: number): number => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];\n  else if (lenBytes === 2) return buf[offset + 1];\n  else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];\n  else if (lenBytes === 4)\n    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw new Error('Length too long (> 4 bytes)');\n};\n\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([\n  ...[0x30, 0x0c], // SEQUENCE\n  ...[0x06, 0x0a], // OID with 10 bytes\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([\n  ...[0x30, 0x05], // SEQUENCE\n  ...[0x06, 0x03], // OID with 3 bytes\n  ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([\n  ...[0x30, 0x10], // SEQUENCE\n  ...[0x06, 0x07], // OID with 7 bytes\n  ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], // OID ECDSA\n  ...[0x06, 0x05], // OID with 5 bytes\n  ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload: ArrayBuffer, oid: Uint8Array): Uint8Array {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n\n  return buf;\n}\n\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded: ArrayBuffer, oid: Uint8Array): Uint8Array => {\n  let offset = 0;\n  const expect = (n: number, msg: string) => {\n    if (buf[offset++] !== n) {\n      throw new Error('Expected: ' + msg);\n    }\n  };\n\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n\n  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw new Error('Not the expected OID.');\n  }\n  offset += oid.byteLength;\n\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw new Error(\n      `DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`,\n    );\n  }\n  return result;\n};\n", "import { DerEncodedPublicKey, PublicKey } from './auth';\nimport { ED25519_OID, unwrapDER, wrapDER } from './der';\n\nexport class Ed25519PublicKey implements PublicKey {\n  public static from(key: PublicKey): Ed25519PublicKey {\n    return this.fromDer(key.toDer());\n  }\n\n  public static fromRaw(rawKey: ArrayBuffer): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    return wrapDER(publicKey, ED25519_OID).buffer as DerEncodedPublicKey;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: ArrayBuffer;\n\n  public get rawKey(): ArrayBuffer {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n", "const RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60_000;\nconst MAX_ELAPSED_TIME_MSEC = 900_000;\nconst MAX_ITERATIONS = 10;\n\nexport type BackoffStrategy = {\n  next: () => number | null;\n  currentInterval?: number;\n  count?: number;\n  ellapsedTimeInMsec?: number;\n};\n\nexport type BackoffStrategyArgs = {\n  maxIterations?: number;\n  maxElapsedTime?: number;\n};\n\nexport type BackoffStrategyFactory = (args?: BackoffStrategyArgs) => BackoffStrategy;\n\n// export type BackoffStrategyGenerator = Generator<number, void, unknown>;\n\nexport type ExponentialBackoffOptions = {\n  initialInterval?: number;\n  randomizationFactor?: number;\n  multiplier?: number;\n  maxInterval?: number;\n  maxElapsedTime?: number;\n  maxIterations?: number;\n  date?: DateConstructor;\n};\n\n/**\n * Exponential backoff strategy.\n */\nexport class ExponentialBackoff {\n  #currentInterval: number;\n  #randomizationFactor: number;\n  #multiplier: number;\n  #maxInterval: number;\n  #startTime: number;\n  #maxElapsedTime: number;\n  #maxIterations: number;\n  #date: DateConstructor;\n  #count = 0;\n\n  static default = {\n    initialInterval: INITIAL_INTERVAL_MSEC,\n    randomizationFactor: RANDOMIZATION_FACTOR,\n    multiplier: MULTIPLIER,\n    maxInterval: MAX_INTERVAL_MSEC,\n    // 1 minute\n    maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n    maxIterations: MAX_ITERATIONS,\n    date: Date,\n  };\n\n  constructor(options: ExponentialBackoffOptions = ExponentialBackoff.default) {\n    const {\n      initialInterval = INITIAL_INTERVAL_MSEC,\n      randomizationFactor = RANDOMIZATION_FACTOR,\n      multiplier = MULTIPLIER,\n      maxInterval = MAX_INTERVAL_MSEC,\n      maxElapsedTime = MAX_ELAPSED_TIME_MSEC,\n      maxIterations = MAX_ITERATIONS,\n      date = Date,\n    } = options;\n    this.#currentInterval = initialInterval;\n    this.#randomizationFactor = randomizationFactor;\n    this.#multiplier = multiplier;\n    this.#maxInterval = maxInterval;\n    this.#date = date;\n    this.#startTime = date.now();\n    this.#maxElapsedTime = maxElapsedTime;\n    this.#maxIterations = maxIterations;\n  }\n\n  get ellapsedTimeInMsec() {\n    return this.#date.now() - this.#startTime;\n  }\n\n  get currentInterval() {\n    return this.#currentInterval;\n  }\n\n  get count() {\n    return this.#count;\n  }\n\n  get randomValueFromInterval() {\n    const delta = this.#randomizationFactor * this.#currentInterval;\n    const min = this.#currentInterval - delta;\n    const max = this.#currentInterval + delta;\n    return Math.random() * (max - min) + min;\n  }\n\n  public incrementCurrentInterval() {\n    this.#currentInterval = Math.min(this.#currentInterval * this.#multiplier, this.#maxInterval);\n    this.#count++;\n\n    return this.#currentInterval;\n  }\n\n  public next() {\n    if (this.ellapsedTimeInMsec >= this.#maxElapsedTime || this.#count >= this.#maxIterations) {\n      return null;\n    } else {\n      this.incrementCurrentInterval();\n      return this.randomValueFromInterval;\n    }\n  }\n}\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nexport function* exponentialBackoff(\n  options: ExponentialBackoffOptions = ExponentialBackoff.default,\n) {\n  const backoff = new ExponentialBackoff(options);\n\n  let next = backoff.next();\n  while (next) {\n    yield next;\n    next = backoff.next();\n  }\n}\n", "import { JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity, Identity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { RequestId, hashOfMap, requestIdOf } from '../../request_id';\nimport { bufFromBufLike, concat, fromHex } from '../../utils/buffer';\nimport {\n  Agent,\n  ApiQueryResponse,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from '../api';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport {\n  CallRequest,\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpAgentSubmitRequest,\n  makeNonce,\n  Nonce,\n  QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n} from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { SubnetStatus, request } from '../../canisterStatus';\nimport {\n  CertificateVerificationError,\n  HashTree,\n  LookupStatus,\n  lookup_path,\n} from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nimport { decodeTime } from '../../utils/leb';\nimport { ObservableLog } from '../../observable';\nimport { BackoffStrategy, BackoffStrategyFactory, ExponentialBackoff } from '../../polling/backoff';\nexport * from './transforms';\nexport { Nonce, makeNonce } from './types';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nclass HttpDefaultFetchError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // Another HttpAgent to inherit configuration (pipeline and fetch) of. This\n  // is only used at construction.\n  source?: HttpAgent;\n\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Adds a unique {@link Nonce} with each query.\n   * Enabling will prevent queries from being answered with a cached response.\n   * @example\n   * const agent = new HttpAgent({ useQueryNonces: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  useQueryNonces?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n  /**\n   * The strategy to use for backoff when retrying requests\n   */\n  backoffStrategy?: BackoffStrategyFactory;\n  /**\n   * Whether the agent should verify signatures signed by node keys on query responses. Increases security, but adds overhead and must make a separate request to cache the node keys for the canister's subnet.\n   * @default true\n   */\n  verifyQuerySignatures?: boolean;\n  /**\n   * Whether to log to the console. Defaults to false.\n   */\n  logToConsole?: boolean;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError(\n    'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n  );\n}\n\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent implements Agent {\n  public rootKey = fromHex(IC_ROOT_KEY);\n  private _identity: Promise<Identity> | null;\n  private readonly _fetch: typeof fetch;\n  private readonly _fetchOptions?: Record<string, unknown>;\n  private readonly _callOptions?: Record<string, unknown>;\n  private _timeDiffMsecs = 0;\n  private readonly _host: URL;\n  private readonly _credentials: string | undefined;\n  private _rootKeyFetched = false;\n  #retryTimes; // Retry requests N times before erroring by default\n  #backoffStrategy: BackoffStrategyFactory;\n  public readonly _isAgent = true;\n\n  // The UTC time in milliseconds when the latest request was made\n  #waterMark = 0;\n\n  get waterMark(): number {\n    return this.#waterMark;\n  }\n\n  public log: ObservableLog = new ObservableLog();\n\n  #queryPipeline: HttpAgentRequestTransformFn[] = [];\n  #updatePipeline: HttpAgentRequestTransformFn[] = [];\n\n  #subnetKeys: ExpirableMap<string, SubnetStatus> = new ExpirableMap({\n    expirationTime: 5 * 60 * 1000, // 5 minutes\n  });\n  #verifyQuerySignatures = true;\n\n  constructor(options: HttpAgentOptions = {}) {\n    if (options.source) {\n      if (!(options.source instanceof HttpAgent)) {\n        throw new Error(\"An Agent's source can only be another HttpAgent\");\n      }\n      this._identity = options.source._identity;\n      this._fetch = options.source._fetch;\n      this._host = options.source._host;\n      this._credentials = options.source._credentials;\n    } else {\n      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n      this._fetchOptions = options.fetchOptions;\n      this._callOptions = options.callOptions;\n    }\n    if (options.host !== undefined) {\n      if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n        this._host = new URL(window.location.protocol + '//' + options.host);\n      } else {\n        this._host = new URL(options.host);\n      }\n    } else if (options.source !== undefined) {\n      // Safe to ignore here.\n      this._host = options.source._host;\n    } else {\n      const location = typeof window !== 'undefined' ? window.location : undefined;\n      if (!location) {\n        this._host = new URL('https://icp-api.io');\n        this.log.warn(\n          'Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.',\n        );\n      }\n      // Mainnet, local, and remote environments will have the api route available\n      const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n      const remoteHosts = ['.github.dev', '.gitpod.io'];\n      const hostname = location?.hostname;\n      let knownHost;\n      if (hostname && typeof hostname === 'string') {\n        if (remoteHosts.some(host => hostname.endsWith(host))) {\n          knownHost = hostname;\n        } else {\n          knownHost = knownHosts.find(host => hostname.endsWith(host));\n        }\n      }\n\n      if (location && knownHost) {\n        // If the user is on a boundary-node provided host, we can use the same host for the agent\n        this._host = new URL(\n          `${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`,\n        );\n      } else {\n        this._host = new URL('https://icp-api.io');\n        this.log.warn(\n          'Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.',\n        );\n      }\n    }\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3\n    this.#retryTimes = options.retryTimes ?? 3;\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () =>\n      new ExponentialBackoff({\n        maxIterations: this.#retryTimes,\n      });\n    this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n    // Rewrite to avoid redirects\n    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this._host.hostname = IC0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this._host.hostname = ICP0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this._host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this._credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this._host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n\n  public addTransform(\n    type: 'update' | 'query',\n    fn: HttpAgentRequestTransformFn,\n    priority = fn.priority || 0,\n  ): void {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(\n        i >= 0 ? i : this.#updatePipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(\n        i >= 0 ? i : this.#queryPipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this._identity) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    return (await this._identity).getPrincipal();\n  }\n\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n\n    const sender: Principal = id.getPrincipal() || Principal.anonymous();\n\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this._timeDiffMsecs) > 1_000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);\n    }\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`,\n      transformedRequest,\n    );\n\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n    const backoff = this.#backoffStrategy();\n    const request = this.#requestAndRetry({\n      request: () =>\n        this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), {\n          ...this._callOptions,\n          ...transformedRequest.request,\n          body,\n        }),\n      backoff,\n      tries: 0,\n    });\n\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n\n    const responseBuffer = await response.arrayBuffer();\n    const responseBody = (\n      response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null\n    ) as SubmitResponse['response']['body'];\n\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        body: responseBody,\n        headers: httpHeadersTransform(response.headers),\n      },\n    };\n  }\n\n  async #requestAndRetryQuery(args: {\n    ecid: Principal;\n    transformedRequest: HttpAgentRequest;\n    body: ArrayBuffer;\n    requestId: RequestId;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<ApiQueryResponse> {\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n      tries,\n      backoff,\n      delay,\n    });\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response: ApiQueryResponse;\n    // Make the request and retry if it throws an error\n    try {\n      this.log.print(\n        `fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`,\n        transformedRequest,\n      );\n      const fetchResponse = await this._fetch(\n        '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this._host),\n        {\n          ...this._fetchOptions,\n          ...transformedRequest.request,\n          body,\n        },\n      );\n      if (fetchResponse.status === 200) {\n        const queryResponse: QueryResponse = cbor.decode(await fetchResponse.arrayBuffer());\n        response = {\n          ...queryResponse,\n          httpDetails: {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n          requestId,\n        };\n      } else {\n        throw new AgentHTTPResponseError(\n          `Gateway returned an error:\\n` +\n            `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` +\n            `  Body: ${await fetchResponse.text()}\\n`,\n          {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n        );\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(\n          `Caught exception while attempting to make query:\\n` +\n            `  ${error}\\n` +\n            `  Retrying query.`,\n        );\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      throw error;\n    }\n\n    const timestamp = response.signatures?.[0]?.timestamp;\n\n    // Skip watermark verification if the user has set verifyQuerySignatures to false\n    if (!this.#verifyQuerySignatures) {\n      return response;\n    }\n\n    if (!timestamp) {\n      throw new Error(\n        'Timestamp not found in query response. This suggests a malformed or malicious response.',\n      );\n    }\n\n    // Convert the timestamp to milliseconds\n    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1_000_000));\n\n    this.log.print('watermark and timestamp', {\n      waterMark: this.waterMark,\n      timestamp: timeStampInMs,\n    });\n\n    // If the timestamp is less than the watermark, retry the request up to the retry limit\n    if (Number(this.waterMark) > timeStampInMs) {\n      const error = new AgentError('Timestamp is below the watermark. Retrying query.');\n      this.log.error('Timestamp is below', error, {\n        timestamp,\n        waterMark: this.waterMark,\n      });\n      if (tries < this.#retryTimes) {\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      {\n        throw new AgentError(\n          `Timestamp failed to pass the watermark after retrying the configured ${\n            this.#retryTimes\n          } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n        );\n      }\n    }\n\n    return response;\n  }\n\n  async #requestAndRetry(args: {\n    request: () => Promise<Response>;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<Response> {\n    const { request, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n\n    let response: Response;\n    try {\n      response = await request();\n    } catch (error) {\n      if (this.#retryTimes > tries) {\n        this.log.warn(\n          `Caught exception while attempting to make request:\\n` +\n            `  ${error}\\n` +\n            `  Retrying request.`,\n        );\n        // Delay the request by the configured backoff strategy\n        return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n      }\n      throw error;\n    }\n    if (response.ok) {\n      return response;\n    }\n\n    const responseText = await response.clone().text();\n    const errorMessage =\n      `Server returned an error:\\n` +\n      `  Code: ${response.status} (${response.statusText})\\n` +\n      `  Body: ${responseText}\\n`;\n\n    if (tries < this.#retryTimes) {\n      return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n    }\n    throw new AgentHTTPResponseError(errorMessage, {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers),\n    });\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse> {\n    const backoff = this.#backoffStrategy();\n    const ecid = fields.effectiveCanisterId\n      ? Principal.from(fields.effectiveCanisterId)\n      : Principal.from(canisterId);\n\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await this._identity);\n      if (!id) {\n        throw new IdentityInvalidError(\n          \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n        );\n      }\n\n      const canister = Principal.from(canisterId);\n      const sender = id?.getPrincipal() || Principal.anonymous();\n\n      const request: QueryRequest = {\n        request_type: ReadRequestType.Query,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      };\n\n      const requestId = await requestIdOf(request);\n\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest: HttpAgentRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/cbor',\n            ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n          },\n        },\n        endpoint: Endpoint.Query,\n        body: request,\n      });\n\n      // Apply transform for identity.\n      transformedRequest = (await id?.transformRequest(transformedRequest)) as HttpAgentRequest;\n\n      const body = cbor.encode(transformedRequest.body);\n\n      const args = {\n        canister: canister.toText(),\n        ecid,\n        transformedRequest,\n        body,\n        requestId,\n        backoff,\n        tries: 0,\n      };\n\n      return await this.#requestAndRetryQuery(args);\n    };\n\n    const getSubnetStatus = async (): Promise<SubnetStatus | void> => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return this.#subnetKeys.get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n\n    this.log.print('Query response:', query);\n    // Skip verification if the user has disabled it\n    if (!this.#verifyQuerySignatures) {\n      return query;\n    }\n\n    try {\n      return this.#verifyQueryResponse(query, subnetStatus);\n    } catch (_) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      this.#subnetKeys.delete(canisterId.toString());\n      await this.fetchSubnetKeys(ecid.toString());\n\n      const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      return this.#verifyQueryResponse(query, updatedSubnetStatus);\n    }\n  }\n\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse = (\n    queryResponse: ApiQueryResponse,\n    subnetStatus: SubnetStatus | void,\n  ): ApiQueryResponse => {\n    if (this.#verifyQuerySignatures === false) {\n      // This should not be called if the user has disabled verification\n      return queryResponse;\n    }\n    if (!subnetStatus) {\n      throw new CertificateVerificationError(\n        'Invalid signature from replica signed query: no matching node key found.',\n      );\n    }\n    const { status, signatures = [], requestId } = queryResponse;\n\n    const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n    for (const sig of signatures) {\n      const { timestamp, identity } = sig;\n      const nodeId = Principal.fromUint8Array(identity).toText();\n      let hash: ArrayBuffer;\n\n      // Hash is constructed differently depending on the status\n      if (status === 'replied') {\n        const { reply } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reply: reply,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else if (status === 'rejected') {\n        const { reject_code, reject_message, error_code } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reject_code: reject_code,\n          reject_message: reject_message,\n          error_code: error_code,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else {\n        throw new Error(`Unknown status: ${status}`);\n      }\n\n      const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n\n      // FIX: check for match without verifying N times\n      const pubKey = subnetStatus?.nodeKeys.get(nodeId);\n      if (!pubKey) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n      const valid = ed25519.verify(\n        sig.signature,\n        new Uint8Array(separatorWithHash),\n        new Uint8Array(rawKey),\n      );\n      if (valid) return queryResponse;\n\n      throw new CertificateVerificationError(\n        `Invalid signature from replica ${nodeId} signed query.`,\n      );\n    }\n    return queryResponse;\n  };\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      },\n    });\n\n    // Apply transform for identity.\n    return id?.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n\n    const transformedRequest = request ?? (await this.createReadStateRequest(fields, identity));\n    const body = cbor.encode(transformedRequest.body);\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${canister}/read_state\" with request:`,\n      transformedRequest,\n    );\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const backoff = this.#backoffStrategy();\n\n    const response = await this.#requestAndRetry({\n      request: () =>\n        this._fetch(\n          '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this._host),\n          {\n            ...this._fetchOptions,\n            ...transformedRequest.request,\n            body,\n          },\n        ),\n      backoff,\n      tries: 0,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Server returned an error:\\n` +\n          `  Code: ${response.status} (${response.statusText})\\n` +\n          `  Body: ${await response.text()}\\n`,\n      );\n    }\n    const decodedResponse: ReadStateResponse = cbor.decode(await response.arrayBuffer());\n\n    this.log.print('Read state response:', decodedResponse);\n    const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n    if (parsedTime > 0) {\n      this.log.print('Read state response time:', parsedTime);\n      this.#waterMark = parsedTime;\n    }\n\n    return decodedResponse;\n  }\n\n  public async parseTimeFromResponse(response: ReadStateResponse): Promise<number> {\n    let tree: HashTree;\n    if (response.certificate) {\n      const decoded: { tree: HashTree } | undefined = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw new Error('Could not decode time from response');\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupStatus.Found) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n\n      if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      const date = decodeTime(bufFromBufLike(timeLookup.value as ArrayBuffer));\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  public async syncTime(canisterId?: Principal): Promise<void> {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        this.log.print(\n          'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n        );\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time'],\n      });\n\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this._timeDiffMsecs = Number(replicaTime as bigint) - Number(callTime);\n      }\n    } catch (error) {\n      this.log.error('Caught exception while attempting to sync time', error as AgentError);\n    }\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this._credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this._credentials),\n        }\n      : {};\n\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = this.#backoffStrategy();\n    const response = await this.#requestAndRetry({\n      backoff,\n      request: () =>\n        this._fetch('' + new URL(`/api/v2/status`, this._host), { headers, ...this._fetchOptions }),\n      tries: 0,\n    });\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    if (!this._rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = ((await this.status()) as JsonObject & { root_key: ArrayBuffer }).root_key;\n      this._rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n\n  public invalidateIdentity(): void {\n    this._identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this._identity = Promise.resolve(identity);\n  }\n\n  public async fetchSubnetKeys(canisterId: Principal | string) {\n    const effectiveCanisterId: Principal = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this,\n    });\n\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse as SubnetStatus);\n      return subnetResponse as SubnetStatus;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n\n    return p;\n  }\n}\n", "import { JsonObject } from '@dfinity/candid';\nimport {\n  Agent,\n  ApiQueryResponse,\n  CallOptions,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from './api';\nimport { Principal } from '@dfinity/principal';\n\nexport enum ProxyMessageKind {\n  Error = 'err',\n  GetPrincipal = 'gp',\n  GetPrincipalResponse = 'gpr',\n  Query = 'q',\n  QueryResponse = 'qr',\n  Call = 'c',\n  CallResponse = 'cr',\n  ReadState = 'rs',\n  ReadStateResponse = 'rsr',\n  Status = 's',\n  StatusResponse = 'sr',\n}\n\nexport interface ProxyMessageBase {\n  id: number;\n  type: ProxyMessageKind;\n}\n\nexport interface ProxyMessageError extends ProxyMessageBase {\n  type: ProxyMessageKind.Error;\n  error: any;\n}\n\nexport interface ProxyMessageGetPrincipal extends ProxyMessageBase {\n  type: ProxyMessageKind.GetPrincipal;\n}\n\nexport interface ProxyMessageGetPrincipalResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.GetPrincipalResponse;\n  response: string;\n}\n\nexport interface ProxyMessageQuery extends ProxyMessageBase {\n  type: ProxyMessageKind.Query;\n  args: [string, QueryFields];\n}\n\nexport interface ProxyMessageQueryResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.QueryResponse;\n  response: QueryResponse;\n}\n\nexport interface ProxyMessageCall extends ProxyMessageBase {\n  type: ProxyMessageKind.Call;\n  args: [string, CallOptions];\n}\n\nexport interface ProxyMessageCallResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.CallResponse;\n  response: SubmitResponse;\n}\n\nexport interface ProxyMessageReadState extends ProxyMessageBase {\n  type: ProxyMessageKind.ReadState;\n  args: [string, ReadStateOptions];\n}\n\nexport interface ProxyMessageReadStateResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.ReadStateResponse;\n  response: ReadStateResponse;\n}\n\nexport interface ProxyMessageStatus extends ProxyMessageBase {\n  type: ProxyMessageKind.Status;\n}\n\nexport interface ProxyMessageStatusResponse extends ProxyMessageBase {\n  type: ProxyMessageKind.StatusResponse;\n  response: JsonObject;\n}\n\nexport type ProxyMessage =\n  | ProxyMessageError\n  | ProxyMessageGetPrincipal\n  | ProxyMessageGetPrincipalResponse\n  | ProxyMessageQuery\n  | ProxyMessageQueryResponse\n  | ProxyMessageCall\n  | ProxyMessageReadState\n  | ProxyMessageReadStateResponse\n  | ProxyMessageCallResponse\n  | ProxyMessageStatus\n  | ProxyMessageStatusResponse;\n\n// A Stub Agent that forwards calls to another Agent implementation.\nexport class ProxyStubAgent {\n  constructor(private _frontend: (msg: ProxyMessage) => void, private _agent: Agent) {}\n\n  public onmessage(msg: ProxyMessage): void {\n    switch (msg.type) {\n      case ProxyMessageKind.GetPrincipal:\n        this._agent.getPrincipal().then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.GetPrincipalResponse,\n            response: response.toText(),\n          });\n        });\n        break;\n      case ProxyMessageKind.Query:\n        this._agent.query(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.QueryResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.Call:\n        this._agent.call(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.CallResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.ReadState:\n        this._agent.readState(...msg.args).then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.ReadStateResponse,\n            response,\n          });\n        });\n        break;\n      case ProxyMessageKind.Status:\n        this._agent.status().then(response => {\n          this._frontend({\n            id: msg.id,\n            type: ProxyMessageKind.StatusResponse,\n            response,\n          });\n        });\n        break;\n\n      default:\n        throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);\n    }\n  }\n}\n\n// An Agent that forwards calls to a backend. The calls are serialized\nexport class ProxyAgent implements Agent {\n  private _nextId = 0;\n  private _pendingCalls = new Map<number, [(resolve: any) => void, (reject: any) => void]>();\n  public rootKey = null;\n\n  constructor(private _backend: (msg: ProxyMessage) => void) {}\n\n  public onmessage(msg: ProxyMessage): void {\n    const id = msg.id;\n\n    const maybePromise = this._pendingCalls.get(id);\n    if (!maybePromise) {\n      throw new Error('A proxy get the same message twice...');\n    }\n\n    this._pendingCalls.delete(id);\n    const [resolve, reject] = maybePromise;\n\n    switch (msg.type) {\n      case ProxyMessageKind.Error:\n        return reject(msg.error);\n      case ProxyMessageKind.GetPrincipalResponse:\n      case ProxyMessageKind.CallResponse:\n      case ProxyMessageKind.QueryResponse:\n      case ProxyMessageKind.ReadStateResponse:\n      case ProxyMessageKind.StatusResponse:\n        return resolve(msg.response);\n      default:\n        throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.GetPrincipal,\n    }).then(principal => {\n      if (typeof principal !== 'string') {\n        throw new Error('Invalid principal received.');\n      }\n      return Principal.fromText(principal);\n    });\n  }\n\n  public readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n  ): Promise<ReadStateResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.ReadState,\n      args: [canisterId.toString(), fields],\n    }) as Promise<ReadStateResponse>;\n  }\n\n  public call(canisterId: Principal | string, fields: CallOptions): Promise<SubmitResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Call,\n      args: [canisterId.toString(), fields],\n    }) as Promise<SubmitResponse>;\n  }\n\n  public status(): Promise<JsonObject> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Status,\n    }) as Promise<JsonObject>;\n  }\n\n  public query(canisterId: Principal | string, fields: QueryFields): Promise<ApiQueryResponse> {\n    return this._sendAndWait({\n      id: this._nextId++,\n      type: ProxyMessageKind.Query,\n      args: [canisterId.toString(), fields],\n    }) as Promise<ApiQueryResponse>;\n  }\n\n  private async _sendAndWait(msg: ProxyMessage): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      this._pendingCalls.set(msg.id, [resolve, reject]);\n\n      this._backend(msg);\n    });\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    // Hex-encoded version of the replica root key\n    const rootKey = ((await this.status()) as any).root_key;\n    this.rootKey = rootKey;\n    return rootKey;\n  }\n}\n", "import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions, lookupResultToBuffer } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy,\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<ArrayBuffer> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return lookupResultToBuffer(cert.lookup([...path, 'reply']))!;\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_message']))!,\n      );\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n", "import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent';\nimport { toHex } from '../utils/buffer';\nimport { PollStrategy } from './index';\nimport { RequestId } from '../request_id';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw new Error(\n        `Failed to retrieve a reply for request after ${count} attempts:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw new Error(\n        `Request timed out after ${timeInMsec} msec:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n", "import { bufEquals } from '@dfinity/agent';\nimport {\n  DerEncodedPublicKey,\n  KeyPair,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  uint8ToBuf,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n  fromHex,\n  toHex,\n  bufFromBufLike,\n} from '@dfinity/agent';\nimport { ed25519 } from '@noble/curves/ed25519';\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  public static from(maybeKey: unknown): Ed25519PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = fromHex(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(bufFromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(key);\n      } else if ('rawKey' in key) {\n        return this.fromRaw(key.rawKey as ArrayBuffer);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer() as ArrayBuffer);\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n\n  public static fromRaw(rawKey: ArrayBuffer): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    const key = wrapDER(publicKey, ED25519_OID).buffer as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: ArrayBuffer;\n\n  public get rawKey(): ArrayBuffer {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  public static generate(seed?: Uint8Array): Ed25519KeyIdentity {\n\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if(bufEquals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn('Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.');\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) sk[i] = new Uint8Array(seed)[i];\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(fromHex(publicKeyDer) as DerEncodedPublicKey),\n      fromHex(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: ArrayBuffer, privateKey: ArrayBuffer): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: ArrayBuffer): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: ArrayBuffer) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = new Uint8Array(privateKey);\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [toHex(this.#publicKey.toDer()), toHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const blob = new Uint8Array(challenge);\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = uint8ToBuf(ed25519.sign(blob, this.#privateKey.slice(0, 32)));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = fromHex(x);\n      }\n      if (x instanceof Uint8Array) {\n        x = x.buffer;\n      }\n      return new Uint8Array(x);\n    });\n    return ed25519.verify(message, signature, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n", "import { DerEncodedPublicKey, PublicKey, Signature, SignIdentity } from '@dfinity/agent';\n\n/**\n * Options used in a {@link ECDSAKeyIdentity}\n */\nexport type CryptoKeyOptions = {\n  extractable?: boolean;\n  keyUsages?: KeyUsage[];\n  subtleCrypto?: SubtleCrypto;\n};\n\nexport class CryptoError extends Error {\n  constructor(public readonly message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n\nexport interface DerCryptoKey extends CryptoKey {\n  toDer: () => DerEncodedPublicKey;\n}\n\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto: CryptoKeyOptions['subtleCrypto']): SubtleCrypto {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError(\n      'Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto',\n    );\n  }\n}\n\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @constructs ECDSAKeyIdentity\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  public static async generate(options?: CryptoKeyOptions): Promise<ECDSAKeyIdentity> {\n    const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      extractable,\n      keyUsages,\n    );\n    const derKey = (await effectiveCrypto.exportKey(\n      'spki',\n      keyPair.publicKey,\n    )) as DerEncodedPublicKey;\n\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  public static async fromKeyPair(\n    keyPair: CryptoKeyPair | { privateKey: CryptoKey; publicKey: CryptoKey },\n    subtleCrypto?: SubtleCrypto,\n  ): Promise<ECDSAKeyIdentity> {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey = (await effectiveCrypto.exportKey(\n      'spki',\n      keyPair.publicKey,\n    )) as DerEncodedPublicKey;\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n\n  protected _derKey: DerEncodedPublicKey;\n  protected _keyPair: CryptoKeyPair;\n  protected _subtleCrypto: SubtleCrypto;\n\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  protected constructor(\n    keyPair: CryptoKeyPair,\n    derKey: DerEncodedPublicKey,\n    subtleCrypto: SubtleCrypto,\n  ) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  public getKeyPair(): CryptoKeyPair {\n    return this._keyPair;\n  }\n\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  public getPublicKey(): PublicKey & DerCryptoKey {\n    const derKey = this._derKey;\n    const key: DerCryptoKey = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n\n    return key;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const params: EcdsaParams = {\n      name: 'ECDSA',\n      hash: { name: 'SHA-256' },\n    };\n    this._keyPair.privateKey;\n    const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);\n\n    return signature as Signature;\n  }\n}\n\nexport default ECDSAKeyIdentity;\n", "import {\n  DerEncodedPublicKey,\n  fromHex,\n  HttpAgentRequest,\n  PublicKey,\n  requestIdOf,\n  Signature,\n  SignIdentity,\n  toHex,\n} from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport * as cbor from 'simple-cbor';\nimport { PartialIdentity } from './partial';\n\nconst domainSeparator = new TextEncoder().encode('\\x1Aic-request-auth-delegation');\nconst requestDomainSeparator = new TextEncoder().encode('\\x0Aic-request');\n\nfunction _parseBlob(value: unknown): ArrayBuffer {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n\n  return fromHex(value);\n}\n\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation {\n  constructor(\n    public readonly pubkey: ArrayBuffer,\n    public readonly expiration: bigint,\n    public readonly targets?: Principal[],\n  ) {}\n\n  public toCBOR(): cbor.CborValue {\n    // Expiration field needs to be encoded as a u64 specifically.\n    return cbor.value.map({\n      pubkey: cbor.value.bytes(this.pubkey),\n      expiration: cbor.value.u64(this.expiration.toString(16), 16),\n      ...(this.targets && {\n        targets: cbor.value.array(this.targets.map(t => cbor.value.bytes(t.toUint8Array()))),\n      }),\n    });\n  }\n\n  public toJSON(): JsonnableDelegation {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: toHex(this.pubkey),\n      ...(this.targets && { targets: this.targets.map(p => p.toHex()) }),\n    };\n  }\n}\n\n/**\n * Type of ReturnType<Delegation.toJSON>.\n * The goal here is to stringify all non-JSON-compatible types to some bytes representation we can\n * stringify as hex.\n * (Hex shouldn't be ambiguous ever, because you can encode as DER with semantic OIDs).\n */\ninterface JsonnableDelegation {\n  // A BigInt of Nanoseconds since epoch as hex\n  expiration: string;\n  // Hexadecimal representation of the DER public key.\n  pubkey: string;\n  // Array of strings, where each string is hex of principal blob (*NOT* textual representation).\n  targets?: string[];\n}\n\n/**\n * A signed delegation, which lends its identity to the public key in the delegation\n * object. This is constructed by `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport interface SignedDelegation {\n  delegation: Delegation;\n  signature: Signature;\n}\n\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(\n  from: SignIdentity,\n  to: PublicKey,\n  expiration: Date,\n  targets?: Principal[],\n): Promise<SignedDelegation> {\n  const delegation: Delegation = new Delegation(\n    to.toDer(),\n    BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets,\n  );\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([\n    ...domainSeparator,\n    ...new Uint8Array(requestIdOf(delegation)),\n  ]);\n  const signature = await from.sign(challenge);\n\n  return {\n    delegation,\n    signature,\n  };\n}\n\nexport interface JsonnableDelegationChain {\n  publicKey: string;\n  delegations: Array<{\n    signature: string;\n    delegation: {\n      pubkey: string;\n      expiration: string;\n      targets?: string[];\n    };\n  }>;\n}\n\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  public static async create(\n    from: SignIdentity,\n    to: PublicKey,\n    expiration: Date = new Date(Date.now() + 15 * 60 * 1000),\n    options: {\n      previous?: DelegationChain;\n      targets?: Principal[];\n    } = {},\n  ): Promise<DelegationChain> {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain(\n      [...(options.previous?.delegations || []), delegation],\n      options.previous?.publicKey || from.getPublicKey().toDer(),\n    );\n  }\n\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  public static fromJSON(json: string | JsonnableDelegationChain): DelegationChain {\n    const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n\n    const parsedDelegations: SignedDelegation[] = delegations.map(signedDelegation => {\n      const { delegation, signature } = signedDelegation;\n      const { pubkey, expiration, targets } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n\n      return {\n        delegation: new Delegation(\n          _parseBlob(pubkey),\n          BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n          targets &&\n            targets.map((t: unknown) => {\n              if (typeof t !== 'string') {\n                throw new Error('Invalid target.');\n              }\n              return Principal.fromHex(t);\n            }),\n        ),\n        signature: _parseBlob(signature) as Signature,\n      };\n    });\n\n    return new this(parsedDelegations, _parseBlob(publicKey) as DerEncodedPublicKey);\n  }\n\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  public static fromDelegations(\n    delegations: SignedDelegation[],\n    publicKey: DerEncodedPublicKey,\n  ): DelegationChain {\n    return new this(delegations, publicKey);\n  }\n\n  protected constructor(\n    public readonly delegations: SignedDelegation[],\n    public readonly publicKey: DerEncodedPublicKey,\n  ) {}\n\n  public toJSON(): JsonnableDelegationChain {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const { delegation, signature } = signedDelegation;\n        const { targets } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: toHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex()),\n            }),\n          },\n          signature: toHex(signature),\n        };\n      }),\n      publicKey: toHex(this.publicKey),\n    };\n  }\n}\n\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the reqyests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  public static fromDelegation(\n    key: Pick<SignIdentity, 'sign'>,\n    delegation: DelegationChain,\n  ): DelegationIdentity {\n    return new this(key, delegation);\n  }\n\n  protected constructor(\n    private _inner: Pick<SignIdentity, 'sign'>,\n    private _delegation: DelegationChain,\n  ) {\n    super();\n  }\n\n  public getDelegation(): DelegationChain {\n    return this._delegation;\n  }\n\n  public getPublicKey(): PublicKey {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey,\n    };\n  }\n  public sign(blob: ArrayBuffer): Promise<Signature> {\n    return this._inner.sign(blob);\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(\n          new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)]),\n        ),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey,\n      },\n    };\n  }\n}\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation: DelegationChain;\n\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation(): DelegationChain {\n    return this.#delegation;\n  }\n\n  private constructor(inner: PublicKey, delegation: DelegationChain) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   * @constructs PartialDelegationIdentity\n   */\n  public static fromDelegation(key: PublicKey, delegation: DelegationChain) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n", "import { Identity, PublicKey } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialIdentity implements Identity {\n  #inner: PublicKey;\n\n  /**\n   * The raw public key of this identity.\n   */\n  get rawKey(): ArrayBuffer | undefined {\n    return this.#inner.rawKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  get derKey(): ArrayBuffer | undefined {\n    return this.#inner.derKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  public toDer(): ArrayBuffer {\n    return this.#inner.toDer();\n  }\n\n  /**\n   * The inner {@link PublicKey} used by this identity.\n   */\n  public getPublicKey(): PublicKey {\n    return this.#inner;\n  }\n\n  /**\n   * The {@link Principal} of this identity.\n   */\n  public getPrincipal(): Principal {\n    return Principal.from(this.#inner.rawKey);\n  }\n\n  /**\n   * Required for the Identity interface, but cannot implemented for just a public key.\n   */\n  public transformRequest(): Promise<never> {\n    return Promise.reject(\n      'Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.',\n    );\n  }\n\n  constructor(inner: PublicKey) {\n    this.#inner = inner;\n  }\n}\n", "import {\n  DerEncodedPublicKey,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  fromHex,\n  toHex,\n} from '@dfinity/agent';\nimport borc from 'borc';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bufFromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: ArrayBuffer): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID).buffer as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: ArrayBuffer): ArrayBuffer {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: ArrayBuffer) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): ArrayBuffer {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: bufFromBufLike(creds.rawId),\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(fromHex(rawId), fromHex(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n\n    return new this(\n      creds.rawId,\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: ArrayBuffer,\n    cose: ArrayBuffer,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: ArrayBuffer): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const cbor = borc.encode(\n      new borc.Tagged(55799, {\n        authenticator_data: new Uint8Array(response.authenticatorData),\n        client_data_json: new TextDecoder().decode(response.clientDataJSON),\n        signature: new Uint8Array(response.signature),\n      }),\n    );\n    if (!cbor) {\n      throw new Error('failed to encode cbor');\n    }\n    return cbor.buffer as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: toHex(this._publicKey.getCose()),\n      rawId: toHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n", "/** @module IdleManager */\ntype IdleCB = () => unknown;\nexport type IdleManagerOptions = {\n  /**\n   * Callback after the user has gone idle\n   */\n  onIdle?: IdleCB;\n  /**\n   * timeout in ms\n   * @default 30 minutes [600_000]\n   */\n  idleTimeout?: number;\n  /**\n   * capture scroll events\n   * @default false\n   */\n  captureScroll?: boolean;\n  /**\n   * scroll debounce time in ms\n   * @default 100\n   */\n  scrollDebounce?: number;\n};\n\nconst events = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'wheel'];\n\n/**\n * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.\n * By default, the IdleManager will log a user out after 10 minutes of inactivity.\n * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds\n */\nexport class IdleManager {\n  callbacks: IdleCB[] = [];\n  idleTimeout: IdleManagerOptions['idleTimeout'] = 10 * 60 * 1000;\n  timeoutID?: number = undefined;\n\n  /**\n   * Creates an {@link IdleManager}\n   * @param {IdleManagerOptions} options Optional configuration\n   * @see {@link IdleManagerOptions}\n   * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user\n   * @param options.idleTimeout timeout in ms\n   * @param options.captureScroll capture scroll events\n   * @param options.scrollDebounce scroll debounce time in ms\n   */\n  public static create(\n    options: {\n      /**\n       * Callback after the user has gone idle\n       * @see {@link IdleCB}\n       */\n      onIdle?: () => unknown;\n      /**\n       * timeout in ms\n       * @default 10 minutes [600_000]\n       */\n      idleTimeout?: number;\n      /**\n       * capture scroll events\n       * @default false\n       */\n      captureScroll?: boolean;\n      /**\n       * scroll debounce time in ms\n       * @default 100\n       */\n      scrollDebounce?: number;\n    } = {},\n  ): IdleManager {\n    return new this(options);\n  }\n\n  /**\n   * @protected\n   * @param options {@link IdleManagerOptions}\n   */\n  protected constructor(options: IdleManagerOptions = {}) {\n    const { onIdle, idleTimeout = 10 * 60 * 1000 } = options || {};\n\n    this.callbacks = onIdle ? [onIdle] : [];\n    this.idleTimeout = idleTimeout;\n\n    const _resetTimer = this._resetTimer.bind(this);\n\n    window.addEventListener('load', _resetTimer, true);\n\n    events.forEach(function (name) {\n      document.addEventListener(name, _resetTimer, true);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const debounce = (func: Function, wait: number) => {\n      let timeout: number | undefined;\n      return (...args: unknown[]) => {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const context = this;\n        const later = function () {\n          timeout = undefined;\n          func.apply(context, args);\n        };\n        clearTimeout(timeout);\n        timeout = window.setTimeout(later, wait);\n      };\n    };\n\n    if (options?.captureScroll) {\n      // debounce scroll events\n      const scroll = debounce(_resetTimer, options?.scrollDebounce ?? 100);\n      window.addEventListener('scroll', scroll, true);\n    }\n\n    _resetTimer();\n  }\n\n  /**\n   * @param {IdleCB} callback function to be called when user goes idle\n   */\n  public registerCallback(callback: IdleCB): void {\n    this.callbacks.push(callback);\n  }\n\n  /**\n   * Cleans up the idle manager and its listeners\n   */\n  public exit(): void {\n    clearTimeout(this.timeoutID);\n    window.removeEventListener('load', this._resetTimer, true);\n\n    const _resetTimer = this._resetTimer.bind(this);\n    events.forEach(function (name) {\n      document.removeEventListener(name, _resetTimer, true);\n    });\n    this.callbacks.forEach(cb => cb());\n  }\n\n  /**\n   * Resets the timeouts during cleanup\n   */\n  _resetTimer(): void {\n    const exit = this.exit.bind(this);\n    window.clearTimeout(this.timeoutID);\n    this.timeoutID = window.setTimeout(exit, this.idleTimeout);\n  }\n}\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import { openDB, IDBPDatabase } from 'idb';\nimport { DB_VERSION, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\n\ntype Database = IDBPDatabase<unknown>;\ntype IDBValidKey = string | number | Date | BufferSource | IDBValidKey[];\nconst AUTH_DB_NAME = 'auth-client-db';\nconst OBJECT_STORE_NAME = 'ic-keyval';\n\nconst _openDbStore = async (\n  dbName = AUTH_DB_NAME,\n  storeName = OBJECT_STORE_NAME,\n  version: number,\n) => {\n  // Clear legacy stored delegations\n  if (isBrowser && localStorage?.getItem(KEY_STORAGE_DELEGATION)) {\n    localStorage.removeItem(KEY_STORAGE_DELEGATION);\n    localStorage.removeItem(KEY_STORAGE_KEY);\n  }\n  return await openDB(dbName, version, {\n    upgrade: database => {\n      database.objectStoreNames;\n      if (database.objectStoreNames.contains(storeName)) {\n        database.clear(storeName);\n      }\n      database.createObjectStore(storeName);\n    },\n  });\n};\n\nasync function _getValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n): Promise<T | undefined> {\n  return await db.get(storeName, key);\n}\n\nasync function _setValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n  value: T,\n): Promise<IDBValidKey> {\n  return await db.put(storeName, value, key);\n}\n\nasync function _removeValue(db: Database, storeName: string, key: IDBValidKey): Promise<void> {\n  return await db.delete(storeName, key);\n}\n\nexport type DBCreateOptions = {\n  dbName?: string;\n  storeName?: string;\n  version?: number;\n};\n\n/**\n * Simple Key Value store\n * Defaults to `'auth-client-db'` with an object store of `'ic-keyval'`\n */\nexport class IdbKeyVal {\n  /**\n   * @param {DBCreateOptions} options - DBCreateOptions\n   * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database\n   * @default\n   * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store\n   * @default\n   * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade\n   * @constructs an {@link IdbKeyVal}\n   */\n  public static async create(options?: DBCreateOptions): Promise<IdbKeyVal> {\n    const { dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version = DB_VERSION } = options ?? {};\n    const db = await _openDbStore(dbName, storeName, version);\n    return new IdbKeyVal(db, storeName);\n  }\n\n  // Do not use - instead prefer create\n  private constructor(private _db: Database, private _storeName: string) {}\n\n  /**\n   * Basic setter\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @param value value to set\n   * @returns void\n   */\n  public async set<T>(key: IDBValidKey, value: T) {\n    return await _setValue<T>(this._db, this._storeName, key, value);\n  }\n  /**\n   * Basic getter\n   * Pass in a type T for type safety if you know the type the value will have if it is found\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @returns `Promise<T | null>`\n   * @example\n   * await get<string>('exampleKey') -> 'exampleValue'\n   */\n  public async get<T>(key: IDBValidKey): Promise<T | null> {\n    return (await _getValue<T>(this._db, this._storeName, key)) ?? null;\n  }\n\n  /**\n   * Remove a key\n   * @param key {@link IDBValidKey}\n   * @returns void\n   */\n  public async remove(key: IDBValidKey) {\n    return await _removeValue(this._db, this._storeName, key);\n  }\n}\n", "import { DBCreateOptions, IdbKeyVal } from './db';\n\nexport const KEY_STORAGE_KEY = 'identity';\nexport const KEY_STORAGE_DELEGATION = 'delegation';\nexport const KEY_VECTOR = 'iv';\n// Increment if any fields are modified\nexport const DB_VERSION = 1;\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport type StoredKey = string | CryptoKeyPair;\n\n/**\n * Interface for persisting user authentication data\n */\nexport interface AuthClientStorage {\n  get(key: string): Promise<StoredKey | null>;\n\n  set(key: string, value: StoredKey): Promise<void>;\n\n  remove(key: string): Promise<void>;\n}\n\n/**\n * Legacy implementation of AuthClientStorage, for use where IndexedDb is not available\n */\nexport class LocalStorage implements AuthClientStorage {\n  constructor(public readonly prefix = 'ic-', private readonly _localStorage?: Storage) {}\n\n  public get(key: string): Promise<string | null> {\n    return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));\n  }\n\n  public set(key: string, value: string): Promise<void> {\n    this._getLocalStorage().setItem(this.prefix + key, value);\n    return Promise.resolve();\n  }\n\n  public remove(key: string): Promise<void> {\n    this._getLocalStorage().removeItem(this.prefix + key);\n    return Promise.resolve();\n  }\n\n  private _getLocalStorage() {\n    if (this._localStorage) {\n      return this._localStorage;\n    }\n\n    const ls =\n      typeof window === 'undefined'\n        ? typeof global === 'undefined'\n          ? typeof self === 'undefined'\n            ? undefined\n            : self.localStorage\n          : global.localStorage\n        : window.localStorage;\n\n    if (!ls) {\n      throw new Error('Could not find local storage.');\n    }\n\n    return ls;\n  }\n}\n\n/**\n * IdbStorage is an interface for simple storage of string key-value pairs built on {@link IdbKeyVal}\n *\n * It replaces {@link LocalStorage}\n * @see implements {@link AuthClientStorage}\n */\nexport class IdbStorage implements AuthClientStorage {\n  #options: DBCreateOptions;\n\n  /**\n   * @param options - DBCreateOptions\n   * @param options.dbName - name for the indexeddb database\n   * @param options.storeName - name for the indexeddb Data Store\n   * @param options.version - version of the database. Increment to safely upgrade\n   * @constructs an {@link IdbStorage}\n   * @example\n   * ```typescript\n   * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });\n   * ```\n   */\n  constructor(options?: DBCreateOptions) {\n    this.#options = options ?? {};\n  }\n\n  // Initializes a KeyVal on first request\n  private initializedDb: IdbKeyVal | undefined;\n  get _db(): Promise<IdbKeyVal> {\n    return new Promise(resolve => {\n      if (this.initializedDb) {\n        resolve(this.initializedDb);\n        return;\n      }\n      IdbKeyVal.create(this.#options).then(db => {\n        this.initializedDb = db;\n        resolve(db);\n      });\n    });\n  }\n\n  public async get<T = string>(key: string): Promise<T | null> {\n    const db = await this._db;\n    return await db.get<T>(key);\n    // return (await db.get<string>(key)) ?? null;\n  }\n\n  public async set<T = string>(key: string, value: T): Promise<void> {\n    const db = await this._db;\n    await db.set(key, value);\n  }\n\n  public async remove(key: string): Promise<void> {\n    const db = await this._db;\n    await db.remove(key);\n  }\n}\n", "/** @module AuthClient */\nimport {\n  AnonymousIdentity,\n  DerEncodedPublicKey,\n  Identity,\n  Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n  PartialDelegationIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, IdleManagerOptions } from './idleManager';\nimport {\n  AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage';\nimport { PartialIdentity } from '@dfinity/identity/lib/cjs/identity/partial';\n\nexport { AuthClientStorage, IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal, DBCreateOptions } from './db';\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An identity to use as the base\n   */\n  identity?: SignIdentity | PartialIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n   */\n  storage?: AuthClientStorage;\n  /**\n   * type to use for the base key\n   * @default 'ECDSA'\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use 'Ed25519' as the key type, as it can serialize to a string\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 30 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager';\n\nexport type OnSuccessFunc =\n  | (() => void | Promise<void>)\n  | ((message: InternetIdentityAuthResponseSuccess) => void | Promise<void>);\n\nexport type OnErrorFunc = (error?: string) => void | Promise<void>;\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.ic0.app\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   */\n  allowPinAuthentication?: boolean;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: OnSuccessFunc;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: OnErrorFunc;\n  /**\n   * Extra values to be passed in the login request during the authorize-ready phase\n   */\n  customValues?: Record<string, unknown>;\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  allowPinAuthentication?: boolean;\n  derivationOrigin?: string;\n}\n\nexport interface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(\n    options: {\n      /**\n       * An {@link SignIdentity} or {@link PartialIdentity} to authenticate via delegation.\n       */\n      identity?: SignIdentity | PartialIdentity;\n      /**\n       * {@link AuthClientStorage}\n       * @description Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n       */\n      storage?: AuthClientStorage;\n      /**\n       * type to use for the base key\n       * @default 'ECDSA'\n       * If you are using a custom storage provider that does not support CryptoKey storage,\n       * you should use 'Ed25519' as the key type, as it can serialize to a string\n       */\n      keyType?: BaseKeyType;\n      /**\n       * Options to handle idle timeouts\n       * @default after 10 minutes, invalidates the identity\n       */\n      idleOptions?: IdleOptions;\n    } = {},\n  ): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | PartialIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch (e) {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity: SignIdentity | PartialIdentity = new AnonymousIdentity() as PartialIdentity;\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined = undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity | PartialIdentity,\n    private _key: SignIdentity | PartialIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    this._registerDefaultIdleCallback();\n  }\n\n  private _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: OnSuccessFunc,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature.buffer as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey.buffer as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3_600_000_000_000);\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      options?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive: options?.maxTimeToLive ?? defaultTimeToLive,\n      ...options,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(identityProviderUrl.toString(), 'idpWindow', options?.windowOpenerFeatures) ??\n      undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(\n          `WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`,\n        );\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer() as ArrayBuffer),\n            maxTimeToLive: options?.maxTimeToLive,\n            allowPinAuthentication: options?.allowPinAuthentication,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n            // Pass any custom values to the IDP.\n            ...options?.customValues,\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (e) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n"],
  "mappings": "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",
  "names": ["Buffer", "value", "concat", "utf8ToBytes", "i", "byteLength", "import_buffer", "ReplicaRejectCode", "request", "SubmitRequestType", "value", "Fp", "Fn", "uvRatio", "p", "adjustScalarBytes", "eddsa", "_0n", "_1n", "_2n", "adjustScalarBytes", "_0n", "_1n", "_2n", "_8n", "_8n", "_2n", "_1n", "mod", "_0n", "__classPrivateFieldSet", "__classPrivateFieldGet", "_a", "RequestStatusResponseStatus", "_HttpAgent_requestAndRetryQuery", "backoff", "__classPrivateFieldGet", "_b", "_a", "_HttpAgent_requestAndRetry", "request", "ProxyMessageKind", "request", "_a", "value", "Ed25519PublicKey", "_Ed25519PublicKey_rawKey", "_Ed25519PublicKey_derKey", "__classPrivateFieldSet", "__classPrivateFieldGet", "cbor", "__classPrivateFieldSet", "__classPrivateFieldGet", "domainSeparator", "value", "_a", "_b", "request", "__rest", "__classPrivateFieldSet", "__classPrivateFieldGet", "chain", "PubKeyCoseAlgo", "timeout", "_a", "request", "value", "request", "target", "value", "_a", "value", "__classPrivateFieldSet", "__classPrivateFieldGet", "_a", "_b", "chain", "request"]
}
