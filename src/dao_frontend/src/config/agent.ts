import { Actor, ActorSubclass, HttpAgent } from "@dfinity/agent";
import type { Identity } from "@dfinity/agent";
import type { IDL } from "@dfinity/candid";
import {
  idlFactory as daoBackendIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as DaoBackendService
} from "@declarations/dao_backend/dao_backend.did.js";
import type { Activity } from "@declarations/dao_backend/dao_backend.did";

type DaoBackendServiceExtended = DaoBackendService & {
  getRecentActivity: () => Promise<Activity[]>;
};
import {
  idlFactory as governanceIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as GovernanceService
} from "@declarations/governance/governance.did.js";
import {
  idlFactory as proposalsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as ProposalsService
} from "@declarations/proposals/proposals.did.js";
import {
  idlFactory as stakingIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as StakingService
} from "@declarations/staking/staking.did.js";
import {
  idlFactory as treasuryIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as TreasuryService
} from "@declarations/treasury/treasury.did.js";
import {
  idlFactory as assetsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as AssetsService,
} from "@declarations/assets/assets.did.js";
import {
  idlFactory as daoRegistryIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as DAORegistryService,
} from "@declarations/dao_registry/dao_registry.did.js";

declare global {
  interface Window {
    global: typeof globalThis;
  }
}

// Ensure global is defined in the browser context
if (typeof window !== "undefined") {
  window.global = window;
}

const createActor = async <T>(
  canisterId: string,
  idlFactory: IDL.InterfaceFactory,
  identity?: Identity
): Promise<ActorSubclass<T>> => {
  try {
    console.log("Creating actor for canister ID:", canisterId);
    
    // Check if canisterId is valid
    if (!canisterId || canisterId === 'undefined' || canisterId.includes('_')) {
      throw new Error(`Invalid canister ID: ${canisterId}`);
    }

    // Determine the correct host based on the environment
    let host = import.meta.env.VITE_HOST;
    
    // If we're in a canister environment, use the current window location
    if (typeof window !== 'undefined' && window.location.hostname.includes('.localhost')) {
      host = `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;
    } else if (!host) {
      host = "http://127.0.0.1:4943";
    }

    console.log("Using host:", host);

    const agent = new HttpAgent({
      host: host,
      verifyQuerySignatures: false,
      identity,
    });

    if (identity) {
      const principal = await agent.getPrincipal();
      console.log("HttpAgent principal:", principal.toString());
    }

    // Only fetch the root key when we're in development
    if (import.meta.env.VITE_DFX_NETWORK !== "ic") {
      await agent.fetchRootKey().catch(err => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }

    return Actor.createActor<T>(idlFactory, {
      agent,
      canisterId,
    });
  } catch (error) {
    console.error("Error creating actor:", error);
    throw error;
  }
};


export const initializeAgents = async (identity?: Identity) => {
  if (import.meta.env.DEV) {
    console.log("=== DEBUGGING ENVIRONMENT VARIABLES ===");
    console.log("All import.meta.env:", import.meta.env);

    const envVars = {
      'VITE_CANISTER_ID_DAO_BACKEND': import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
      'VITE_CANISTER_ID_GOVERNANCE': import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
      'VITE_CANISTER_ID_STAKING': import.meta.env.VITE_CANISTER_ID_STAKING,
      'VITE_CANISTER_ID_TREASURY': import.meta.env.VITE_CANISTER_ID_TREASURY,
      'VITE_CANISTER_ID_PROPOSALS': import.meta.env.VITE_CANISTER_ID_PROPOSALS,
      'VITE_CANISTER_ID_ASSETS': import.meta.env.VITE_CANISTER_ID_ASSETS,
      'VITE_CANISTER_ID_INTERNET_IDENTITY': import.meta.env.VITE_CANISTER_ID_INTERNET_IDENTITY,
    };

    Object.entries(envVars).forEach(([key, value]) => {
      console.log(`${key}:`, value);
      console.log(`  Type: ${typeof value}`);
      console.log(`  Length: ${value ? value.length : 'N/A'}`);
      console.log(`  Contains underscore: ${value ? value.includes('_') : 'N/A'}`);
      console.log(
        `  Raw characters:`,
        value ? [...value].map(c => `${c}(${c.charCodeAt(0)})`).join(' ') : 'N/A'
      );
    });
  }


  try {
    // Create actors for required canisters
    const daoBackend = await createActor<DaoBackendServiceExtended>(
      import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
      daoBackendIdl,
      identity
    );

    const dao_registry = await createActor<DAORegistryService>(
      import.meta.env.VITE_CANISTER_ID_DAO_REGISTRY,
      daoRegistryIdl,
      identity
    );

    const assets = await createActor<AssetsService>(
      import.meta.env.VITE_CANISTER_ID_ASSETS,
      assetsIdl,
      identity
    );

    // Create mock actors for optional canisters during development if they don't exist
    // In production, missing canister IDs will throw an error instead of creating mocks
    const createMockActor = <T>(): ActorSubclass<T> => {
      return new Proxy({} as ActorSubclass<T>, {
        get: (target, prop) => {
          if (typeof prop === 'string') {
            return async (...args: any[]) => {
              console.warn(`Mock actor method called: ${prop}`, args);
              // Return appropriate mock data based on method name
              if (prop.includes('getUserAssets') || prop.includes('getPublicAssets')) {
                return []; // Return empty array for asset list methods
              }
              if (prop.includes('getStorageStats')) {
                return { totalAssets: 0, storageUsed: 0, storageLimit: 1000000000, storageAvailable: 1000000000, averageFileSize: 0 };
              }
              if (prop.includes('uploadAsset')) {
                return { ok: Math.floor(Math.random() * 1000) }; // Return mock asset ID
              }
              if (prop.includes('get') || prop.includes('fetch') || prop.includes('list')) {
                return null;
              }
              return { ok: true };
            };
          }
          return target[prop as keyof ActorSubclass<T>];
        }
      });
    };

    // Helper to handle optional canisters
    const handleOptionalActor = async <T>(
      canisterId: string | undefined,
      idl: IDL.InterfaceFactory,
      name: string
    ): Promise<ActorSubclass<T>> => {
      if (!canisterId) {
        if (import.meta.env.DEV) {
          return createMockActor<T>();
        }
        throw new Error(`Missing environment variable: VITE_CANISTER_ID_${name}`);
      }
      try {
        return await createActor<T>(canisterId, idl, identity);
      } catch (error) {
        if (import.meta.env.DEV) {
          console.warn(`Failed to create ${name.toLowerCase()} actor, using mock:`, error);
          return createMockActor<T>();
        }
        throw error;
      }
    };

    // Create actors, using mocks only in development
    let governance: ActorSubclass<GovernanceService>;
    let staking: ActorSubclass<StakingService>;
    let treasury: ActorSubclass<TreasuryService>;
    let proposals: ActorSubclass<ProposalsService>;

    governance = await handleOptionalActor<GovernanceService>(
      import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
      governanceIdl,
      "GOVERNANCE"
    );

    staking = await handleOptionalActor<StakingService>(
      import.meta.env.VITE_CANISTER_ID_STAKING,
      stakingIdl,
      "STAKING"
    );

    treasury = await handleOptionalActor<TreasuryService>(
      import.meta.env.VITE_CANISTER_ID_TREASURY,
      treasuryIdl,
      "TREASURY"
    );

    proposals = await handleOptionalActor<ProposalsService>(
      import.meta.env.VITE_CANISTER_ID_PROPOSALS,
      proposalsIdl,
      "PROPOSALS"
    );

    return {
      daoBackend,
      dao_registry,
      governance,
      staking,
      treasury,
      proposals,
      assets,
    };
  } catch (error) {
    console.error("Failed to initialize agents:", error);
    throw error;
  }
};
