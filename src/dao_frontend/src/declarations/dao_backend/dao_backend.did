type UserProfile = 
 record {
   bio: text;
   displayName: text;
   id: UserId;
   joinedAt: Time;
   reputation: nat;
   totalStaked: nat;
   votingPower: nat;
 };
type UserId = principal;
type TokenAmount = nat;
type Time = int;
type Result_1 = 
 variant {
   err: text;
   ok: nat;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type ModuleFeature = 
 record {
   features: vec text;
   moduleId: text;
 };
type DAOStats =
record {
   activeProposals: nat;
   totalMembers: nat;
   totalProposals: nat;
   totalStaked: TokenAmount;
   totalVotingPower: nat;
   treasuryBalance: TokenAmount;
};
type Activity =
 record {
   activityType: text;
   title: text;
   description: text;
   timestamp: Time;
   status: text;
 };
type DAOConfig =
record {
   category: text;
   fundingDuration: nat;
   fundingGoal: nat;
   initialPrice: nat;
   kycRequired: bool;
   minInvestment: nat;
   moduleFeatures: vec ModuleFeature;
   proposalThreshold: nat;
   quorumThreshold: nat;
   selectedModules: vec text;
   termsAccepted: bool;
   tokenName: text;
   tokenSymbol: text;
   totalSupply: nat;
   votingPeriod: nat;
   website: text;
 };
service : {
  addAdmin: (newAdmin: principal) -> (Result);
  adminRegisterUser: (newUser: principal, displayName: text, bio: text) ->
   (Result);
  checkIsAdmin: ("principal": principal) -> (bool) query;
  createProposal: (title: text, _description: text, _proposalType: text) ->
   (Result_1);
  getAllUsers: () -> (vec UserProfile) query;
  getCanisterReferences: () ->
   (record {
      governance: opt principal;
      proposals: opt principal;
      staking: opt principal;
      treasury: opt principal;
    }) query;
  getDAOConfig: () -> (opt DAOConfig) query;
  getDAOInfo: () ->
   (record {
      description: text;
      initialized: bool;
      name: text;
      totalMembers: nat;
    }) query;
  getDAOStats: () -> (DAOStats) query;
  getRecentActivity: () -> (vec Activity) query;
  getGovernanceStats: () ->
   (record {
      activeProposals: nat;
      passedProposals: nat;
      totalProposals: nat;
      totalVotingPower: nat;
    });
  getUserProfile: (userId: principal) -> (opt UserProfile) query;
  greet: (name: text) -> (text) query;
  health: () -> (record {
                   status: text;
                   timestamp: int;
                 }) query;
  /// * Initialize the DAO with basic configuration
  ///      * 
  ///      * This is the first function called when setting up a new DAO.
  ///      * It establishes the foundational parameters and admin structure.
  ///      * 
  ///      * @param name - Human-readable name for the DAO
  ///      * @param description - Brief description of the DAO's purpose
  ///      * @param initialAdmins - Array of Principal IDs who will have admin privileges
  ///      * @returns Result indicating success or failure with error message
  initialize: (name: text, description: text, initialAdmins:
   vec principal) -> (Result);
  registerUser: (displayName: text, bio: text) -> (Result);
  removeAdmin: (adminToRemove: principal) -> (Result);
  /// * Set references to other canisters in the DAO ecosystem
  ///      * 
  ///      * This establishes the microservices architecture by connecting
  ///      * the main canister to specialized function canisters.
  ///      * 
  ///      * @param governance - Principal ID of the governance canister
  ///      * @param staking - Principal ID of the staking canister  
  ///      * @param treasury - Principal ID of the treasury canister
  ///      * @param proposals - Principal ID of the proposals canister
  ///      * @returns Result indicating success or failure
  setCanisterReferences: (governance: principal, staking: principal,
   treasury: principal, proposals: principal) -> (Result);
  setDAOConfig: (config: DAOConfig) -> (Result);
  updateUserProfile: (displayName: text, bio: text) -> (Result);
  vote: (proposalId: nat, choice: text, _reason: opt text) -> (Result);
}
