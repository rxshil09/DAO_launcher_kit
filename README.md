# `dao2`

Welcome to your our `dao launcher kit` project and to the Internet Computer development community. 

To learn more before you start working with `dao2`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Rust Canister Development Guide](https://internetcomputer.org/docs/current/developer-docs/backend/rust/)
- [ic-cdk](https://docs.rs/ic-cdk)
- [ic-cdk-macros](https://docs.rs/ic-cdk-macros)
- [Candid Introduction](https://internetcomputer.org/docs/current/developer-docs/backend/candid/)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd dao2/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor

<br>

# Module Registry Canister for DAO Governance
The Module Registry Canister is a core component in modular DAO architecture, responsible for managing and governing DAO modules (such as voting, treasury, staking, or analytics). It serves as a decentralized registry where modules can be registered, upgraded, deprecated, or replaced through transparent governance proposals.

ðŸ›  Key Functions
- Module Registration: Add new modules with metadata (name, type, version, canister ID).

- Governance Hooks: Allow DAO members to propose changes to modules and vote on upgrades.

- Version Control: Track module versions and support safe upgrades and rollbacks.

- Access Control: Ensure only authorized entities or DAO decisions can modify the registry.

This canister ensures plug-and-play flexibility, allowing a DAO to evolve its functionality without compromising core integrity. It lays the foundation for a sustainable, upgradable, and community-driven governance framework.

<br>

# ðŸ—³ï¸ Governance Canister for DAO Module Management

This canister handles decentralized governance for managing and evolving modular components of a DAO, such as treasury, staking, and voting modules. It enables transparent proposal creation, voting, and module upgrades via community consensus.

## ðŸ”§ Key Features

- **Proposal System**: Members can propose upgrades or additions to DAO modules.
- **Voting Mechanism**: Weighted or 1-person-1-vote style voting on proposals.
- **Module Registry**: Tracks registered modules with metadata, versions, and canister IDs.
- **Execution Logic**: Applies approved proposals to upgrade or register modules.

## ðŸ“ Interface Summary (Candid)

```candid
service : {
  propose_module_change : (ModuleProposal) -> (nat);

  vote_on_proposal : (nat, principal, variant { yes; no }) -> (variant { ok : text; err : text });

  execute_proposal : (nat) -> (variant { ok : text; err : text });

  get_module : (text) -> (opt ModuleInfo) query;

  list_modules : () -> (vec ModuleInfo) query;

  list_proposals : () -> (vec Proposal) query;
}
```

<br>

# ðŸ’° Treasury Canister for DAO Fund Management

This canister manages treasury operations for a DAO, including receiving contributions, tracking balances, and processing approved disbursements. It integrates with the Governance Canister to ensure all spending is proposal-driven and transparent.

## ðŸ”§ Key Features

- **Fund Reception**: Accepts contributions from DAO members or external users.
- **Balance Tracking**: Maintains treasury balance in cycles or tokens.
- **Disbursement Control**: Releases funds only upon approved governance proposals.
- **Auditability**: Exposes full transaction history for transparency.

## ðŸ“ Interface Summary (Candid)

```candid
service : {
  deposit : () -> (variant { ok : text; err : text });
  
  get_balance : () -> (nat) query;

  request_funds : (principal, nat, text) -> (variant { ok : text; err : text });

  execute_transfer : (principal, nat) -> (variant { ok : text; err : text });

  get_transaction_log : () -> (vec record { principal; nat; text }) query;
}
```